import { findByLabelName, } from "@allurereport/core-api";
import { emptyStatistic } from "@allurereport/core-api";
import { md5 } from "./misc.js";
const addLeaf = (node, nodeId) => {
    if (node.leaves === undefined) {
        node.leaves = [];
    }
    if (node.leaves.find((value) => value === nodeId)) {
        return;
    }
    node.leaves.push(nodeId);
};
const addGroup = (node, nodeId) => {
    if (node.groups === undefined) {
        node.groups = [];
    }
    if (node.groups.find((value) => value === nodeId)) {
        return;
    }
    node.groups.push(nodeId);
};
const createTree = (data, classifier, leafFactory, groupFactory, addLeafToGroup = () => { }) => {
    const groupsByClassifier = {};
    const leavesById = {};
    const groupsById = {};
    const root = { groups: [], leaves: [] };
    for (const item of data) {
        const leaf = leafFactory(item);
        leavesById[leaf.nodeId] = leaf;
        const itemGroups = classifier(item);
        let parentGroups = [root];
        for (const layer of itemGroups) {
            if (layer.length === 0) {
                break;
            }
            parentGroups = layer.flatMap((group) => {
                return parentGroups.map((parentGroup) => {
                    const parentId = "nodeId" in parentGroup ? parentGroup.nodeId : "";
                    if (groupsByClassifier[parentId] === undefined) {
                        groupsByClassifier[parentId] = {};
                    }
                    if (groupsByClassifier[parentId][group] === undefined) {
                        const newGroup = groupFactory(parentId, group);
                        groupsByClassifier[parentId][group] = newGroup;
                        groupsById[newGroup.nodeId] = newGroup;
                    }
                    const currentGroup = groupsByClassifier[parentId][group];
                    addGroup(parentGroup, currentGroup.nodeId);
                    addLeafToGroup(currentGroup, leaf);
                    return currentGroup;
                });
            });
        }
        parentGroups.forEach((parentGroup) => addLeaf(parentGroup, leaf.nodeId));
    }
    return {
        root,
        groupsById,
        leavesById,
    };
};
export const byLabels = (item, labelNames) => {
    return labelNames.map((labelName) => item.labels.filter((label) => labelName === label.name).map((label) => label.value ?? "__unknown") ?? []);
};
export const filterTreeLabels = (data, labelNames) => {
    return [...labelNames]
        .reverse()
        .filter((labelName) => data.find((item) => findByLabelName(item.labels, labelName)))
        .reverse();
};
export const createTreeByLabels = (data, labelNames, leafFactory, groupFactory, addLeafToGroup = () => { }) => {
    const leafFactoryFn = leafFactory ??
        ((tr) => {
            const { id, name, status, duration } = tr;
            return {
                nodeId: id,
                name,
                status,
                duration,
            };
        });
    const groupFactoryFn = groupFactory ??
        ((parentId, groupClassifier) => ({
            nodeId: md5((parentId ? `${parentId}.` : "") + groupClassifier),
            name: groupClassifier,
            statistic: emptyStatistic(),
        }));
    return createTree(data, (item) => byLabels(item, labelNames), leafFactoryFn, groupFactoryFn, addLeafToGroup);
};
export const createTreeByCategories = (data, leafFactory, groupFactory, addLeafToGroup = () => { }) => {
    const leafFactoryFn = leafFactory ??
        ((tr) => {
            const { id, name, status, duration } = tr;
            return {
                nodeId: id,
                name,
                status,
                duration,
            };
        });
    const groupFactoryFn = groupFactory ??
        ((parentId, groupClassifier) => ({
            nodeId: md5((parentId ? `${parentId}.` : "") + groupClassifier),
            name: groupClassifier,
            statistic: emptyStatistic(),
        }));
    return createTree(data, (item) => byCategories(item), leafFactoryFn, groupFactoryFn, addLeafToGroup);
};
export const byCategories = (item) => {
    return [item.categories?.map((category) => category.name)];
};
export const preciseTreeLabels = (labelNames, trs, labelNamesAccessor = (tr) => tr.labels.map(({ name }) => name)) => {
    const result = new Set();
    for (const labelName of labelNames) {
        if (trs.some((tr) => labelNamesAccessor(tr).includes(labelName))) {
            result.add(labelName);
        }
    }
    return Array.from(result);
};
export const filterTree = (tree, predicate) => {
    const visitedGroups = new Set();
    const { root, leavesById, groupsById } = tree;
    const filterGroupLeaves = (group) => {
        if (!predicate) {
            return group;
        }
        if (group.groups?.length) {
            group.groups.forEach((groupId) => {
                const subGroup = groupsById[groupId];
                if (!subGroup || visitedGroups.has(groupId)) {
                    return;
                }
                filterGroupLeaves(subGroup);
                visitedGroups.add(groupId);
            });
        }
        if (group.leaves?.length) {
            group.leaves = group.leaves.filter((leaveId) => predicate(leavesById[leaveId]));
        }
        return group;
    };
    filterGroupLeaves(root);
    return tree;
};
export const sortTree = (tree, comparator) => {
    const visitedGroups = new Set();
    const { root, leavesById, groupsById } = tree;
    const sortGroupLeaves = (group) => {
        if (!comparator) {
            return group;
        }
        if (group.groups?.length) {
            group.groups.forEach((groupId) => {
                if (visitedGroups.has(groupId)) {
                    return;
                }
                sortGroupLeaves(groupsById[groupId]);
                visitedGroups.add(groupId);
            });
        }
        if (group.leaves?.length) {
            group.leaves = group.leaves.sort((a, b) => {
                const leafA = leavesById[a];
                const leafB = leavesById[b];
                return comparator(leafA, leafB);
            });
        }
        return group;
    };
    sortGroupLeaves(root);
    return tree;
};
export const transformTree = (tree, transformer) => {
    const visitedGroups = new Set();
    const { root, leavesById, groupsById } = tree;
    const transformGroupLeaves = (group) => {
        if (!transformer) {
            return group;
        }
        if (group.groups?.length) {
            group.groups.forEach((groupId) => {
                if (visitedGroups.has(groupId)) {
                    return;
                }
                transformGroupLeaves(groupsById[groupId]);
                visitedGroups.add(groupId);
            });
        }
        if (group.leaves?.length) {
            group.leaves.forEach((leaf, i) => {
                leavesById[leaf] = transformer(leavesById[leaf], i);
            });
        }
        return group;
    };
    transformGroupLeaves(root);
    return tree;
};
export const createTreeByTitlePath = (data, leafFactory, groupFactory, addLeafToGroup = () => { }) => {
    const leafFactoryFn = leafFactory ??
        ((tr) => {
            const { id, name, status, duration } = tr;
            return {
                nodeId: id,
                name,
                status,
                duration,
            };
        });
    const groupFactoryFn = groupFactory ??
        ((parentId, groupClassifier) => ({
            nodeId: md5((parentId ? `${parentId}.` : "") + groupClassifier),
            name: groupClassifier,
            statistic: emptyStatistic(),
        }));
    return createTree(data, (item) => (item.titlePath ?? []).map((segment) => [segment]), leafFactoryFn, groupFactoryFn, addLeafToGroup);
};
const byLabelsAndTitlePath = (item, labelNames) => {
    const leaves = [];
    for (const labelName of labelNames) {
        const values = item.labels.filter((label) => label.name === labelName).map((label) => label.value ?? "");
        if (!values.length) {
            continue;
        }
        leaves.push(values);
    }
    const titlePath = item.titlePath;
    if (Array.isArray(titlePath) && titlePath.length > 0) {
        for (const segment of titlePath) {
            leaves.push([segment]);
        }
    }
    return leaves;
};
export const createTreeByLabelsAndTitlePath = (data, labelNames = [], leafFactory, groupFactory, addLeafToGroup = () => { }) => {
    const leafFactoryFn = leafFactory ??
        ((tr) => {
            const { id, name, status, duration } = tr;
            return {
                nodeId: id,
                name,
                status,
                duration,
            };
        });
    const groupFactoryFn = groupFactory ??
        ((parentId, groupClassifier) => ({
            nodeId: md5((parentId ? `${parentId}.` : "") + groupClassifier),
            name: groupClassifier,
            statistic: emptyStatistic(),
        }));
    return createTree(data, (item) => byLabelsAndTitlePath(item, labelNames), leafFactoryFn, groupFactoryFn, addLeafToGroup);
};
