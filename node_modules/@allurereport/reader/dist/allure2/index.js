import { notNull } from "@allurereport/core-api";
import { XMLParser } from "fast-xml-parser";
import * as console from "node:console";
import { randomUUID } from "node:crypto";
import { parseProperties } from "../properties.js";
import { ensureBoolean, ensureInt, ensureString } from "../utils.js";
import { cleanBadXmlCharacters, isStringAnyRecord, isStringAnyRecordArray } from "../xml-utils.js";
import { ParameterMode } from "./model.js";
const arrayTags = new Set(["environment.parameter"]);
const xmlParser = new XMLParser({
    parseTagValue: false,
    ignoreAttributes: false,
    attributeNamePrefix: "",
    removeNSPrefix: true,
    allowBooleanAttributes: true,
    isArray: (tagName, jPath) => arrayTags.has(jPath),
});
const readerId = "allure2";
export const allure2 = {
    read: async (visitor, data) => {
        if (data.getOriginalFileName().match(/-attachment(?:\..+)?/)) {
            await visitor.visitAttachmentFile(data, { readerId });
            return true;
        }
        if (data.getOriginalFileName().endsWith("-result.json")) {
            try {
                const parsed = await data.asJson();
                if (parsed && isStringAnyRecord(parsed)) {
                    await processTestResult(visitor, parsed, data.getOriginalFileName());
                }
                return true;
            }
            catch (e) {
                console.error("error parsing", data.getOriginalFileName(), e);
                return false;
            }
        }
        if (data.getOriginalFileName().endsWith("-container.json")) {
            const parsed = await data.asJson();
            if (parsed) {
                await processTestResultContainer(visitor, parsed);
            }
            return true;
        }
        if (data.getOriginalFileName() === "executor.json") {
            try {
                const parsed = await data.asJson();
                if (parsed && isStringAnyRecord(parsed)) {
                    await processExecutor(visitor, parsed);
                }
                return true;
            }
            catch (e) {
                console.error("error parsing", data.getOriginalFileName(), e);
                return false;
            }
        }
        if (data.getOriginalFileName() === "categories.json") {
            try {
                const parsed = await data.asJson();
                if (parsed && isStringAnyRecordArray(parsed)) {
                    await processCategories(visitor, parsed);
                }
                return true;
            }
            catch (e) {
                console.error("error parsing", data.getOriginalFileName(), e);
                return false;
            }
        }
        if (data.getOriginalFileName() === "environment.properties") {
            try {
                const raw = await data.asUtf8String();
                if (raw) {
                    const parsed = parseProperties(raw);
                    if (parsed && isStringAnyRecord(parsed)) {
                        await processEnvironment(visitor, parsed);
                    }
                }
                return true;
            }
            catch (e) {
                console.error("error parsing", data.getOriginalFileName(), e);
                return false;
            }
        }
        if (data.getOriginalFileName() === "environment.xml") {
            try {
                const asBuffer = await data.asBuffer();
                if (!asBuffer) {
                    return false;
                }
                const content = cleanBadXmlCharacters(asBuffer).toString("utf-8");
                const parsed = xmlParser.parse(content);
                if (isStringAnyRecord(parsed)) {
                    await processEnvironmentXml(visitor, parsed);
                }
                return true;
            }
            catch (e) {
                console.error("error parsing", data.getOriginalFileName(), e);
                return false;
            }
        }
        return false;
    },
    readerId: () => readerId,
};
const processTestResult = async (visitor, result, originalFileName) => {
    const dest = {
        uuid: ensureString(result.uuid),
        titlePath: result?.titlePath?.length ? result.titlePath : [],
        fullName: ensureString(result.fullName),
        name: ensureString(result.name),
        testId: ensureString(result.testCaseId),
        historyId: ensureString(result.historyId),
        start: ensureInt(result.start),
        stop: ensureInt(result.stop),
        description: ensureString(result.description),
        descriptionHtml: ensureString(result.descriptionHtml),
        status: convertStatus(result.status),
        message: ensureString(result?.statusDetails?.message),
        trace: ensureString(result?.statusDetails?.trace),
        actual: ensureString(result?.statusDetails?.actual, ""),
        expected: ensureString(result?.statusDetails?.expected, ""),
        flaky: ensureBoolean(result?.statusDetails?.flaky),
        known: ensureBoolean(result?.statusDetails?.known),
        muted: ensureBoolean(result?.statusDetails?.muted),
        parameters: result?.parameters?.filter(notNull)?.map(convertParameter),
        steps: [
            ...(result?.steps?.filter(notNull)?.map(convertStep) ?? []),
            ...(result?.attachments?.filter(notNull)?.map(convertAttachment) ?? []),
        ],
        links: result?.links?.filter(notNull)?.map(convertLink),
        labels: result.labels?.filter(notNull)?.map(convertLabel),
    };
    await visitor.visitTestResult(dest, { readerId, metadata: { originalFileName } });
};
const processExecutor = async (visitor, result) => {
    await visitor.visitMetadata({
        allure2_executor: {
            name: ensureString(result.name),
            type: ensureString(result.type),
            url: ensureString(result.url),
            buildOrder: ensureInt(result.buildOrder),
            buildName: ensureString(result.buildName),
            buildUrl: ensureString(result.buildUrl),
            reportName: ensureString(result.reportName),
            reportUrl: ensureString(result.reportUrl),
        },
    }, { readerId });
};
const processCategories = async (visitor, result) => {
    const data = result.map((value) => ({
        name: ensureString(value.name),
        description: ensureString(value.description),
        descriptionHtml: ensureString(value.descriptionHtml),
        messageRegex: ensureString(value.messageRegex),
        traceRegex: ensureString(value.traceRegex),
        matchedStatuses: Array.isArray(value.matchedStatuses)
            ? value.matchedStatuses.map((v) => ensureString(v)).filter(notNull)
            : [],
        flaky: ensureBoolean(value.flaky),
    }));
    await visitor.visitMetadata({
        allure2_categories: data,
    }, { readerId });
};
const processEnvironmentXml = async (visitor, result) => {
    const { environment } = result;
    if (!isStringAnyRecord(environment)) {
        return;
    }
    const { parameter: parameters } = environment;
    if (!isStringAnyRecordArray(parameters)) {
        return;
    }
    const data = [];
    parameters.forEach((param) => {
        const { key, value } = param;
        const stringKey = ensureString(key);
        const stringValue = ensureString(value);
        if (stringKey && stringValue) {
            data.push({ name: stringKey, values: [stringValue] });
        }
    });
    await visitor.visitMetadata({
        allure_environment: data,
    }, {
        readerId,
    });
};
const processEnvironment = async (visitor, result) => {
    const data = Object.keys(result).map((key) => {
        const rawValue = result[key];
        const value = typeof rawValue === "string" ? rawValue : JSON.stringify(rawValue);
        return {
            name: key,
            values: [value],
        };
    });
    await visitor.visitMetadata({
        allure_environment: data,
    }, {
        readerId,
    });
};
const processFixtures = async (visitor, fixtures, type, children) => {
    if (fixtures) {
        for (const fixture of fixtures) {
            const dist = convertFixture(type, children, fixture);
            await visitor.visitTestFixtureResult(dist, { readerId });
        }
    }
};
const processTestResultContainer = async (visitor, result) => {
    if (result.children && result.children.length > 0) {
        await processFixtures(visitor, result.befores, "before", result.children);
        await processFixtures(visitor, result.afters, "after", result.children);
    }
};
const convertStatus = (status) => {
    switch ((status ?? "unknown").toLowerCase()) {
        case "failed":
            return "failed";
        case "broken":
            return "broken";
        case "passed":
            return "passed";
        case "skipped":
            return "skipped";
        default:
            return "unknown";
    }
};
const convertFixture = (type, children, fixture) => {
    return {
        uuid: randomUUID(),
        testResults: children,
        type,
        name: fixture.name,
        start: ensureInt(fixture.start),
        stop: ensureInt(fixture.stop),
        status: convertStatus(fixture.status),
        message: ensureString(fixture?.statusDetails?.message),
        trace: ensureString(fixture?.statusDetails?.trace),
        steps: [
            ...(fixture?.steps?.filter(notNull)?.map(convertStep) ?? []),
            ...(fixture?.attachments?.filter(notNull)?.map(convertAttachment) ?? []),
        ],
    };
};
const convertStep = (step) => {
    const steps = step?.steps ?? [];
    const attachments = step?.attachments ?? [];
    if (steps.length === 0 && attachments.length === 1 && step.name === attachments[0].name) {
        return {
            ...convertAttachment(attachments[0]),
            start: step.start,
            stop: step.stop,
        };
    }
    return {
        name: ensureString(step.name),
        parameters: step?.parameters?.filter(notNull)?.map(convertParameter),
        status: convertStatus(step.status),
        message: ensureString(step?.statusDetails?.message),
        trace: ensureString(step?.statusDetails?.trace),
        steps: [
            ...(steps.filter(notNull)?.map(convertStep) ?? []),
            ...(attachments.filter(notNull)?.map(convertAttachment) ?? []),
        ],
        start: ensureInt(step.start),
        stop: ensureInt(step.stop),
        type: "step",
    };
};
const convertParameter = ({ mode, name, value, excluded }) => {
    return {
        name: ensureString(name),
        value: ensureString(value),
        excluded: ensureBoolean(excluded),
        hidden: mode === ParameterMode.HIDDEN,
        masked: mode === ParameterMode.MASKED,
    };
};
const convertAttachment = ({ name, type, source }) => {
    return {
        name: ensureString(name),
        contentType: ensureString(type),
        originalFileName: ensureString(source),
        type: "attachment",
    };
};
const convertLabel = ({ name, value }) => {
    return {
        name: ensureString(name),
        value: ensureString(value),
    };
};
const convertLink = ({ name, url, type }) => {
    return {
        name: ensureString(name),
        url: ensureString(url),
        type: ensureString(type),
    };
};
