import { invokeStdoutCliTool, isDefined } from "@allurereport/reader-api";
import { lstat } from "node:fs/promises";
import { platform } from "node:os";
import path from "node:path";
const XCODE_INSTALL_URL = "https://developer.apple.com/documentation/safari-developer-tools/installing-xcode-and-simulators";
const XCODE_SWITCH_COMMAND = "sudo xcode-select -s /Applications/Xcode.app/Contents/Developer";
export const XCRESULTTOOL_MISSING_MESSAGE = `'xcresulttool' is required to parse Xcode Result bundles, but we can't \
access it on this machine. This tool is a part of Xcode. Please make sure Xcode is installed. Visit this page to learn \
more about the installation:

    ${XCODE_INSTALL_URL}

Note that 'xcresulttool' doesn't come with Command Line Tools for Xcode. You need to install the full Xcode package to \
get it. If you have both installed, make sure the full installation is selected. Switch to it with xcode-select if \
necessary (the path to Xcode's Developer directory might be different on your machine):

    ${XCODE_SWITCH_COMMAND}

The original error that led to this message is shown below.
`;
const MDLS_CONTENT_TYPE_PATTERN = /\s*"(?<uti>[^"]+)"/;
const bundleInfoFilePaths = new Set([
    "Info.plist",
    "Contents/Info.plist",
    "Support Files/Info.plist",
    "Resources/Info.plist",
]);
export const IS_MAC = platform() === "darwin";
export const isXcResultBundle = async (directory) => {
    const hasXcResultUti = IS_MAC
        ? await checkUniformTypeIdentifier(directory, "com.apple.xcode.resultbundle")
        : undefined;
    return hasXcResultUti ?? (await isMostProbablyXcResultBundle(directory));
};
export const checkUniformTypeIdentifier = async (itemPath, uti) => {
    const mdlsArgs = ["-raw", "-attr", "kMDItemContentTypeTree", itemPath];
    let contentTypeTreeAvailable = false;
    try {
        for await (const line of invokeStdoutCliTool("mdls", mdlsArgs, { encoding: "utf-8" })) {
            const match = MDLS_CONTENT_TYPE_PATTERN.exec(line);
            if (match) {
                contentTypeTreeAvailable = true;
                const [, matchedUti] = match;
                if (matchedUti === uti) {
                    return true;
                }
            }
        }
    }
    catch {
        return undefined;
    }
    return contentTypeTreeAvailable ? false : undefined;
};
export const isMostProbablyXcResultBundle = async (directory) => isDefined(await findBundleInfoFile(directory)) || followsXcResultNaming(directory);
export const followsXcResultNaming = (directory) => directory.endsWith(".xcresult");
export const findBundleInfoFile = async (directory) => {
    for (const infoFilePath of bundleInfoFilePaths) {
        const infoFileAbsPath = path.join(directory, infoFilePath);
        try {
            const stat = await lstat(infoFileAbsPath);
            if (stat.isFile()) {
                return infoFileAbsPath;
            }
        }
        catch { }
    }
};
