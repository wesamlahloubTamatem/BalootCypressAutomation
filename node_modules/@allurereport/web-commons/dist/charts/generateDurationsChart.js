import { ChartType, } from "@allurereport/charts-api";
import { createHashStorage } from "./utils.js";
const BY_NONE = "none";
const BY_LAYER = "layer";
const MAX_BUCKETS = 5;
const getDurations = (trs) => {
    const durations = new Set();
    for (const tr of trs) {
        const duration = tr.duration ?? (tr.stop ?? 0) - (tr.start ?? 0);
        durations.add(duration);
    }
    return durations;
};
const enrichAndFilterTrs = (trs, groupBy) => {
    const enrichedTrs = [];
    for (const tr of trs) {
        const enrichedTr = {
            ...tr,
            duration: tr.duration ?? (tr.stop ?? 0) - (tr.start ?? 0),
        };
        if (groupBy === BY_LAYER) {
            const layer = tr.labels?.find((l) => l.name === "layer")?.value;
            if (!layer) {
                continue;
            }
            enrichedTr.layer = layer;
        }
        enrichedTrs.push(enrichedTr);
    }
    return enrichedTrs;
};
const getBucketsFromDurations = (durations) => {
    if (durations.length === 0) {
        return [];
    }
    const sortedDurations = [...durations].sort((a, b) => a - b);
    const min = sortedDurations[0];
    const max = sortedDurations[sortedDurations.length - 1];
    const bucketSize = Math.max(1, Math.ceil((max - min + 1) / MAX_BUCKETS));
    const bucketsMap = new Map();
    for (const duration of sortedDurations) {
        const bucketIndex = Math.floor((duration - min) / bucketSize);
        const bucketFrom = min + bucketIndex * bucketSize;
        const bucketTo = Math.min(bucketFrom + bucketSize - 1, max);
        if (!bucketsMap.has(bucketFrom)) {
            bucketsMap.set(bucketFrom, { from: bucketFrom, to: bucketTo });
        }
    }
    return Array.from(bucketsMap.values()).sort((a, b) => a.from - b.from);
};
export const generateDurationsChart = (props) => {
    const { options, storeData } = props;
    const { groupBy = BY_NONE, title } = options;
    const { testResults } = storeData;
    const enrichedTrs = enrichAndFilterTrs(testResults, groupBy);
    const durations = getDurations(enrichedTrs);
    const buckets = durations.size > 0 ? getBucketsFromDurations(Array.from(durations)) : [];
    const hashes = createHashStorage();
    const keys = {};
    if (groupBy === BY_NONE) {
        keys[hashes.get(BY_NONE)] = BY_NONE;
    }
    for (const tr of enrichedTrs) {
        const bucket = buckets.find((b) => tr.duration >= b.from && tr.duration <= b.to);
        if (groupBy === BY_LAYER) {
            const layer = tr.layer;
            keys[hashes.get(layer)] = layer;
            bucket[hashes.get(layer)] = (bucket[hashes.get(layer)] ?? 0) + 1;
        }
        if (groupBy === BY_NONE) {
            bucket[hashes.get(BY_NONE)] = (bucket[hashes.get(BY_NONE)] ?? 0) + 1;
        }
    }
    return {
        data: buckets,
        type: ChartType.Durations,
        title,
        keys,
        groupBy,
    };
};
