import { ChartType, DEFAULT_CHART_HISTORY_LIMIT, } from "@allurereport/charts-api";
import { htrsByTr } from "@allurereport/core-api";
import { limitHistoryDataPoints } from "./chart-utils.js";
const getLastSignificantStatus = (history = []) => {
    const significantHtr = [...history]
        .sort((a, b) => (b.start ?? 0) - (a.start ?? 0))
        .find((htr) => htr.status !== "unknown" && htr.status !== "skipped");
    return significantHtr?.status;
};
const getStatusTransition = (tr, history = []) => {
    if (history.length === 0) {
        return "new";
    }
    if (tr.transition) {
        return tr.transition;
    }
    const lastStatus = getLastSignificantStatus(history);
    if (lastStatus === tr.status) {
        return;
    }
    switch (tr.status) {
        case "passed":
            return "fixed";
        case "failed":
            return "regressed";
        case "broken":
            return "malfunctioned";
    }
};
export const generateStatusTransitionsChart = (props) => {
    const { options, storeData } = props;
    const { limit = DEFAULT_CHART_HISTORY_LIMIT } = options;
    const { historyDataPoints, testResults } = storeData;
    const limitedHdps = limitHistoryDataPoints(historyDataPoints, limit).sort((a, b) => a.timestamp - b.timestamp);
    const currentReportTimestamp = testResults.reduce((acc, testResult) => Math.max(acc, testResult.stop ?? 0), 0);
    if (limitedHdps.length === 0) {
        return {
            type: ChartType.StatusTransitions,
            title: options.title,
            data: [
                {
                    id: "current",
                    timestamp: currentReportTimestamp,
                    prevItemTimestamp: 0,
                    fixed: 0,
                    regressed: 0,
                    malfunctioned: 0,
                },
            ],
        };
    }
    const [earliestHdp, ...hdps] = limitedHdps;
    const data = [];
    [
        ...hdps,
        {
            testResults: testResults.reduce((acc, testResult) => {
                acc[testResult.historyId ?? testResult.id] = testResult;
                return acc;
            }, {}),
            uuid: "current",
            timestamp: currentReportTimestamp,
        },
    ].forEach(({ testResults: trs, uuid, timestamp }, index, dataPoints) => {
        const hpsPriorToCurrent = index === 0 ? [earliestHdp] : dataPoints.slice(0, index);
        const latestHpPriorToCurrent = hpsPriorToCurrent[hpsPriorToCurrent.length - 1];
        const newDataItem = {
            id: uuid,
            timestamp,
            prevItemTimestamp: latestHpPriorToCurrent.timestamp,
            fixed: 0,
            regressed: 0,
            malfunctioned: 0,
        };
        data.push(newDataItem);
        const cTrs = Object.values(trs);
        for (const cTr of cTrs) {
            const htrs = htrsByTr(hpsPriorToCurrent, cTr);
            const transition = getStatusTransition(cTr, htrs);
            if (!transition || transition === "new") {
                continue;
            }
            newDataItem[transition]++;
        }
    });
    return {
        type: ChartType.StatusTransitions,
        title: options.title,
        data,
    };
};
