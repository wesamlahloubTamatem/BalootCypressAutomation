import { createTreeByLabels, md5 } from "@allurereport/plugin-api";
import { isChildrenLeavesOnly } from "../chart-utils.js";
import { convertTreeDataToTreeMapNode, transformTreeMapNode } from "../treeMap.js";
import { behaviorLabels, filterTestsWithBehaviorLabels } from "./utils/behavior.js";
const groupFactoryFn = (parentId, groupClassifier) => ({
    nodeId: md5((parentId ? `${parentId}.` : "") + groupClassifier),
    name: groupClassifier,
    value: 0,
    newCount: 0,
    deletedCount: 0,
    disabledCount: 0,
    enabledCount: 0,
});
const addLeafToGroupFn = (group, leaf) => {
    group.value += leaf.value;
    switch (leaf.changeType) {
        case "new":
            group.newCount++;
            break;
        case "deleted":
            group.deletedCount++;
            break;
        case "enabled":
            group.enabledCount++;
            break;
        case "disabled":
            group.disabledCount++;
            break;
    }
};
const calculateColorValue = (metrics) => {
    const netChange = metrics.newCount + metrics.enabledCount - (metrics.deletedCount + metrics.disabledCount);
    const normalizedChange = netChange / metrics.totalTests;
    return Math.max(0, Math.min(1, (normalizedChange + 1) / 2));
};
const isSkipped = (tr) => tr.status === "skipped";
const getNewTestResults = (trs, closestHtrs) => {
    return trs.filter((tr) => !closestHtrs[tr.historyId]);
};
const getRemovedTestResults = (trs, closestHtrs) => {
    const historyPointTestResultsAsArray = Object.values(closestHtrs);
    const testResultsAsDictionary = Object.fromEntries(trs.map((tr) => [tr.historyId, tr]));
    return historyPointTestResultsAsArray.filter((htr) => !testResultsAsDictionary[htr.historyId]);
};
const getEnabledTestResults = (trs, closestHtrs) => {
    return trs.filter((tr) => {
        const historyPointTestResult = closestHtrs[tr.historyId];
        return historyPointTestResult && isSkipped(historyPointTestResult) && !isSkipped(tr);
    });
};
const getDisabledTestResults = (trs, closestHtrs) => {
    return trs.filter((tr) => {
        const historyPointTestResult = closestHtrs[tr.historyId];
        return historyPointTestResult && !isSkipped(historyPointTestResult) && isSkipped(tr);
    });
};
const calculateSubtreeMetrics = (node) => {
    if (!node.children || node.children.length === 0) {
        const changeType = node?.changeType;
        return {
            totalTests: 1,
            newCount: changeType === "new" ? 1 : 0,
            deletedCount: changeType === "deleted" ? 1 : 0,
            disabledCount: changeType === "disabled" ? 1 : 0,
            enabledCount: changeType === "enabled" ? 1 : 0,
        };
    }
    let totalTests = 0;
    let newCount = 0;
    let deletedCount = 0;
    let disabledCount = 0;
    let enabledCount = 0;
    for (const child of node.children) {
        const childMetrics = calculateSubtreeMetrics(child);
        totalTests += childMetrics.totalTests;
        newCount += childMetrics.newCount;
        deletedCount += childMetrics.deletedCount;
        disabledCount += childMetrics.disabledCount;
        enabledCount += childMetrics.enabledCount;
    }
    return { totalTests, newCount, deletedCount, disabledCount, enabledCount };
};
const createCoverageDiffTreeMap = (trs, closestHtrs) => {
    const newTrs = getNewTestResults(trs, closestHtrs);
    const removedHtrs = getRemovedTestResults(trs, closestHtrs);
    const enabledTrs = getEnabledTestResults(trs, closestHtrs);
    const disabledTrs = getDisabledTestResults(trs, closestHtrs);
    const newTestsById = new Map(newTrs.map((tr) => [tr.historyId, tr]));
    const deletedTestsById = new Map(removedHtrs.map((htr) => [htr.historyId, htr]));
    const enabledTestsById = new Map(enabledTrs.map((tr) => [tr.historyId, tr]));
    const disabledTestsById = new Map(disabledTrs.map((tr) => [tr.historyId, tr]));
    const allTests = [...trs, ...removedHtrs];
    const getChangeType = (historyId) => {
        if (newTestsById.has(historyId)) {
            return "new";
        }
        if (deletedTestsById.has(historyId)) {
            return "deleted";
        }
        if (enabledTestsById.has(historyId)) {
            return "enabled";
        }
        if (disabledTestsById.has(historyId)) {
            return "disabled";
        }
        return "unchanged";
    };
    const leafFactoryFnWithMaps = (test) => {
        const changeType = getChangeType(test.historyId);
        return {
            nodeId: test.id,
            name: test.name,
            value: 1,
            changeType,
        };
    };
    const treeByLabels = createTreeByLabels(allTests, behaviorLabels, leafFactoryFnWithMaps, groupFactoryFn, addLeafToGroupFn);
    const convertedTree = convertTreeDataToTreeMapNode(treeByLabels, (node, isGroup) => {
        const baseNode = {
            id: node.name,
            value: isGroup ? undefined : node.value,
        };
        if (isGroup) {
            const group = node;
            return {
                ...baseNode,
                newCount: group.newCount,
                deletedCount: group.deletedCount,
                disabledCount: group.disabledCount,
                enabledCount: group.enabledCount,
            };
        }
        else {
            const leaf = node;
            return {
                ...baseNode,
                changeType: leaf.changeType,
                newCount: leaf.changeType === "new" ? 1 : 0,
                deletedCount: leaf.changeType === "deleted" ? 1 : 0,
                disabledCount: leaf.changeType === "disabled" ? 1 : 0,
                enabledCount: leaf.changeType === "enabled" ? 1 : 0,
            };
        }
    }, () => ({
        id: "root",
        newCount: 0,
        deletedCount: 0,
        disabledCount: 0,
        enabledCount: 0,
    }));
    return transformTreeMapNode(convertedTree, (node) => {
        const subtreeMetrics = calculateSubtreeMetrics(node);
        const colorValue = calculateColorValue(subtreeMetrics);
        const { totalTests, ...restSubtreeMetrics } = subtreeMetrics;
        if (isChildrenLeavesOnly(node)) {
            return {
                ...node,
                value: totalTests,
                children: undefined,
                colorValue,
                ...restSubtreeMetrics,
            };
        }
        return {
            ...node,
            colorValue,
            ...restSubtreeMetrics,
        };
    });
};
export const coverageDiffTreeMapAccessor = {
    getTreeMap: ({ testResults, historyDataPoints }) => {
        const testsWithBehaviorLabels = filterTestsWithBehaviorLabels(testResults);
        if (!historyDataPoints || historyDataPoints.length === 0) {
            return createCoverageDiffTreeMap(testsWithBehaviorLabels, {});
        }
        const closestHdp = historyDataPoints[0];
        const closestHtrs = closestHdp.testResults;
        const closestHtrsWithBehaviorLabels = filterTestsWithBehaviorLabels(Object.values(closestHtrs));
        const closestHtrsWithBehaviorLabelsById = Object.fromEntries(closestHtrsWithBehaviorLabels.map((htr) => [htr.historyId, htr]));
        return createCoverageDiffTreeMap(testsWithBehaviorLabels, closestHtrsWithBehaviorLabelsById);
    },
};
