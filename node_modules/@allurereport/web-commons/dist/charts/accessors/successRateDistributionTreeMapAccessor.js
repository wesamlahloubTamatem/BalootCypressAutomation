import { createTreeByLabels, md5 } from "@allurereport/plugin-api";
import { isChildrenLeavesOnly } from "../chart-utils.js";
import { convertTreeDataToTreeMapNode, transformTreeMapNode } from "../treeMap.js";
import { behaviorLabels, filterTestsWithBehaviorLabels } from "./utils/behavior.js";
const leafFactoryFn = ({ id, name, status }) => ({
    nodeId: id,
    name,
    status,
    value: 1,
});
const groupFactoryFn = (parentId, groupClassifier) => ({
    nodeId: md5((parentId ? `${parentId}.` : "") + groupClassifier),
    name: groupClassifier,
    value: 0,
    passedTests: 0,
    failedTests: 0,
    otherTests: 0,
});
const addLeafToGroupFn = (group, leaf) => {
    group.value += leaf.value;
    group.passedTests += leaf.status === "passed" ? 1 : 0;
    group.failedTests += leaf.status === "failed" ? 1 : 0;
    group.otherTests += leaf?.status && !["passed", "failed"].includes(leaf.status) ? 1 : 0;
};
const calculateColorValue = ({ totalTests, passedTests }) => {
    return totalTests > 0 ? passedTests / totalTests : 0;
};
const calculateSubtreeMetrics = (node) => {
    if (!node.children || node.children.length === 0) {
        return {
            totalTests: 1,
            passedTests: node?.status === "passed" ? 1 : 0,
            failedTests: node?.status === "failed" ? 1 : 0,
            otherTests: node?.status && !["passed", "failed"].includes(node.status) ? 1 : 0,
        };
    }
    let totalTests = 0;
    let passedTests = 0;
    let failedTests = 0;
    let otherTests = 0;
    for (const child of node.children) {
        const childMetrics = calculateSubtreeMetrics(child);
        totalTests += childMetrics.totalTests;
        passedTests += childMetrics.passedTests;
        failedTests += childMetrics.failedTests;
        otherTests += childMetrics.otherTests;
    }
    return { totalTests, passedTests, failedTests, otherTests };
};
export const createSuccessRateDistributionTreeMap = (testResults) => {
    const treeByLabels = createTreeByLabels(testResults, behaviorLabels, leafFactoryFn, groupFactoryFn, addLeafToGroupFn);
    const convertedTree = convertTreeDataToTreeMapNode(treeByLabels, (node, isGroup) => {
        const baseNode = {
            id: node.name,
            value: isGroup ? undefined : node.value,
        };
        if (isGroup) {
            const group = node;
            return {
                ...baseNode,
                passedTests: group.passedTests,
                failedTests: group.failedTests,
                otherTests: group.otherTests,
            };
        }
        else {
            const leaf = node;
            return {
                ...baseNode,
                status: leaf.status,
                passedTests: leaf?.status === "passed" ? 1 : 0,
                failedTests: leaf?.status === "failed" ? 1 : 0,
                otherTests: leaf?.status && !["passed", "failed"].includes(leaf.status) ? 1 : 0,
            };
        }
    }, () => ({
        id: "root",
        passedTests: 0,
        failedTests: 0,
        otherTests: 0,
    }));
    return transformTreeMapNode(convertedTree, (node) => {
        const subtreeMetrics = calculateSubtreeMetrics(node);
        const colorValue = calculateColorValue(subtreeMetrics);
        const { totalTests, ...restSubtreeMetrics } = subtreeMetrics;
        if (isChildrenLeavesOnly(node)) {
            const value = node.children?.reduce((acc, child) => {
                return acc + (child.value ?? 0);
            }, 0);
            return {
                ...node,
                value,
                children: undefined,
                colorValue,
                ...restSubtreeMetrics,
            };
        }
        return {
            ...node,
            colorValue,
            ...restSubtreeMetrics,
        };
    });
};
export const successRateDistributionTreeMapAccessor = {
    getTreeMap: ({ testResults }) => {
        const testsWithBehaviorLabels = filterTestsWithBehaviorLabels(testResults);
        return createSuccessRateDistributionTreeMap(testsWithBehaviorLabels);
    },
};
