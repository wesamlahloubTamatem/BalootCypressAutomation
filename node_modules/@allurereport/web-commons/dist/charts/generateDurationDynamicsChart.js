import { ChartType, DEFAULT_CHART_HISTORY_LIMIT } from "@allurereport/charts-api";
import { limitHistoryDataPoints } from "./chart-utils.js";
const getStats = (testResults) => {
    const stats = {
        duration: 0,
        sequentialDuration: 0,
        speedup: 0,
    };
    if (testResults.length === 0) {
        return stats;
    }
    const intervals = [];
    for (const tr of testResults) {
        const testStart = tr.start ?? 0;
        const testStop = tr.stop ?? 0;
        const testDuration = Math.max(0, testStop - testStart);
        stats.sequentialDuration += testDuration;
        if (testDuration > 0) {
            intervals.push([testStart, testStop]);
        }
    }
    intervals.sort((a, b) => a[0] - b[0]);
    if (intervals.length > 0) {
        let [mergedStart, mergedEnd] = intervals[0];
        for (let i = 1; i < intervals.length; i++) {
            const [start, end] = intervals[i];
            if (start <= mergedEnd) {
                mergedEnd = Math.max(mergedEnd, end);
            }
            else {
                stats.duration += mergedEnd - mergedStart;
                mergedStart = start;
                mergedEnd = end;
            }
        }
        stats.duration += mergedEnd - mergedStart;
    }
    if (stats.duration > 0) {
        stats.speedup = Math.round((stats.sequentialDuration / stats.duration) * 100) / 100;
    }
    return stats;
};
export const generateDurationDynamicsChart = (props) => {
    const { options, storeData } = props;
    const { title, limit = DEFAULT_CHART_HISTORY_LIMIT } = options;
    const { historyDataPoints, testResults } = storeData;
    const limitedHistoryPoints = limitHistoryDataPoints(historyDataPoints, limit - 1).sort((a, b) => a.timestamp - b.timestamp);
    const currentReportTimestamp = testResults.reduce((acc, testResult) => Math.max(acc, testResult.stop ?? 0), 0);
    if (limitedHistoryPoints.length === 0) {
        return {
            type: ChartType.DurationDynamics,
            title,
            data: [
                {
                    id: "current",
                    timestamp: currentReportTimestamp,
                    ...getStats(testResults),
                },
            ],
        };
    }
    const data = [
        ...limitedHistoryPoints,
        {
            testResults: testResults.reduce((acc, testResult) => {
                acc[testResult.historyId ?? testResult.id] = testResult;
                return acc;
            }, {}),
            uuid: "current",
            timestamp: currentReportTimestamp,
            stats: getStats(testResults),
        },
    ].map((point) => ({
        id: point.uuid,
        timestamp: point.timestamp,
        ...getStats(Object.values(point.testResults)),
    }));
    return {
        data,
        type: ChartType.DurationDynamics,
        title,
    };
};
