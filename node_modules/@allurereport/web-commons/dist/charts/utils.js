import { ChartType } from "@allurereport/charts-api";
import { interpolateRgb } from "d3-interpolate";
import { scaleLinear } from "d3-scale";
import { nanoid } from "nanoid";
import { resolveCSSVarColor, statusColors } from "./colors.js";
export const createTreeMapChartDataGeneric = (getChart, colors, formatLegend, legendDomain, tooltipRows) => {
    const chart = getChart();
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors,
        formatLegend,
        legendDomain,
        tooltipRows,
    };
};
export const createHeatMapChartDataGeneric = (getChart, colors) => {
    const chart = getChart();
    if (!chart) {
        return undefined;
    }
    return {
        ...chart,
        colors,
    };
};
export const createSuccessRateDistributionTreeMapChartData = (chartId, res) => {
    const chartColorDomain = [0, 1];
    return createTreeMapChartDataGeneric(() => res[chartId], (value, domain = chartColorDomain) => {
        const scaledRgb = scaleLinear()
            .domain(domain)
            .range([resolveCSSVarColor(statusColors.failed), resolveCSSVarColor(statusColors.passed)])
            .interpolate(interpolateRgb)
            .clamp(true);
        return scaledRgb(value);
    }, (value) => {
        if (value === 1) {
            return "passed";
        }
        return "failed";
    }, chartColorDomain, (node) => {
        return [`passed: ${node.data.passedTests}`, `failed: ${node.data.failedTests}`, `other: ${node.data.otherTests}`];
    });
};
export const createCoverageDiffTreeMapChartData = (chartId, res) => {
    const chartColorDomain = [0, 0.5, 1];
    return createTreeMapChartDataGeneric(() => res[chartId], (value, domain = chartColorDomain) => {
        const scaledRgb = scaleLinear()
            .domain(domain)
            .range([resolveCSSVarColor(statusColors.failed), "#fff", resolveCSSVarColor(statusColors.passed)])
            .interpolate(interpolateRgb)
            .clamp(true);
        return scaledRgb(value);
    }, (value) => {
        if (value === 1) {
            return "new";
        }
        return "removed";
    }, chartColorDomain, (node) => {
        const newTotal = node.data.newCount + node.data.enabledCount;
        const deletedTotal = node.data.deletedCount + node.data.disabledCount;
        const unchangedTotal = node.value - newTotal - deletedTotal;
        return [`new: ${newTotal}`, `deleted: ${deletedTotal}`, `unchanged: ${unchangedTotal}`];
    });
};
export const createProblemsDistributionHeatMapChartData = (chartId, res) => {
    const chartColorDomain = [0, 1];
    return createHeatMapChartDataGeneric(() => res[chartId], (value, domain = chartColorDomain) => {
        const scaledRgb = scaleLinear()
            .domain(domain)
            .range([resolveCSSVarColor(statusColors.passed), resolveCSSVarColor(statusColors.failed)])
            .interpolate(interpolateRgb)
            .clamp(true);
        return scaledRgb(value);
    });
};
export const createTreeMapChartData = (chartId, chartData, res) => {
    if (chartData.type === ChartType.SuccessRateDistribution) {
        return createSuccessRateDistributionTreeMapChartData(chartId, res);
    }
    else if (chartData.type === ChartType.CoverageDiff) {
        return createCoverageDiffTreeMapChartData(chartId, res);
    }
};
export const createHeatMapChartData = (chartId, res) => {
    return createProblemsDistributionHeatMapChartData(chartId, res);
};
export const createCharts = (res) => {
    return Object.entries(res).reduce((acc, [chartId, chart]) => {
        if (chart.type === ChartType.CurrentStatus) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.StatusDynamics) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.StatusTransitions) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.Durations) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.StabilityDistribution) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.TestBaseGrowthDynamics) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.FBSUAgePyramid) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.TrSeverities) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.DurationDynamics) {
            acc[chartId] = res[chartId];
        }
        else if (chart.type === ChartType.CoverageDiff || chart.type === ChartType.SuccessRateDistribution) {
            const chartData = createTreeMapChartData(chartId, chart, res);
            if (chartData) {
                acc[chartId] = chartData;
            }
        }
        else if (chart.type === ChartType.ProblemsDistribution) {
            const chartData = createHeatMapChartData(chartId, res);
            if (chartData) {
                acc[chartId] = chartData;
            }
        }
        else if (chart.type === ChartType.TestingPyramid) {
            acc[chartId] = res[chartId];
        }
        return acc;
    }, {});
};
export const createChartsWithEnvs = (res) => {
    if (!("general" in res) && !("byEnv" in res)) {
        return { general: createCharts(res), byEnv: {} };
    }
    const result = {
        general: createCharts(res.general),
        byEnv: {},
    };
    for (const [env, chartData] of Object.entries(res.byEnv)) {
        result.byEnv[env] = createCharts(chartData);
    }
    return result;
};
export const createHashStorage = () => {
    const hashes = new Map();
    return {
        get: (key) => {
            if (!hashes.has(key)) {
                hashes.set(key, nanoid());
            }
            return hashes.get(key);
        },
        set: (key, value) => hashes.set(key, value),
    };
};
export const createMapWithDefault = (defaultValue) => {
    const map = new Map();
    const createDefaultValue = () => {
        if (Array.isArray(defaultValue)) {
            return [...defaultValue];
        }
        if (typeof defaultValue === "object") {
            return { ...defaultValue };
        }
        return defaultValue;
    };
    return {
        set: (key, value) => map.set(key, value),
        get: (key) => {
            if (!map.has(key)) {
                map.set(key, createDefaultValue());
            }
            return map.get(key);
        },
        get values() {
            return Array.from(map.values());
        },
        get entries() {
            return Array.from(map.entries());
        },
    };
};
