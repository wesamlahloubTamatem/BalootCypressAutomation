import { ChartDataType, ChartMode, DEFAULT_CHART_HISTORY_LIMIT } from "@allurereport/charts-api";
import { severityTrendDataAccessor } from "./accessors/severityTrendAccessor.js";
import { statusTrendDataAccessor } from "./accessors/statusTrendAccessor.js";
import { createEmptySeries, normalizeStatistic } from "./chart-utils.js";
export const calculatePercentValues = (stats, executionId, itemType) => {
    const points = {};
    const series = createEmptySeries(itemType);
    const values = Object.values(stats);
    const total = values.reduce((sum, value) => sum + value, 0);
    if (total === 0) {
        return { points, series };
    }
    itemType.forEach((item) => {
        const pointId = `${executionId}-${item}`;
        const value = stats[item] ?? 0;
        points[pointId] = {
            x: executionId,
            y: value / total,
        };
        series[item].push(pointId);
    });
    return { points, series };
};
const calculateRawValues = (stats, executionId, itemType) => {
    const points = {};
    const series = createEmptySeries(itemType);
    itemType.forEach((item) => {
        const pointId = `${executionId}-${item}`;
        const value = stats[item] ?? 0;
        points[pointId] = {
            x: executionId,
            y: value,
        };
        series[item].push(pointId);
    });
    return { points, series };
};
export const getTrendDataGeneric = (stats, reportName, executionOrder, itemType, chartOptions) => {
    const { type, dataType, title, mode = ChartMode.Raw, metadata = {} } = chartOptions;
    const { executionIdAccessor, executionNameAccessor } = metadata;
    const executionId = executionIdAccessor ? executionIdAccessor(executionOrder) : `execution-${executionOrder}`;
    const { points, series } = mode === ChartMode.Percent
        ? calculatePercentValues(stats, executionId, itemType)
        : calculateRawValues(stats, executionId, itemType);
    const slices = {};
    const pointsAsArray = Object.values(points);
    const pointsCount = pointsAsArray.length;
    const values = pointsAsArray.map((point) => point.y);
    const min = pointsCount ? Math.min(...values) : 0;
    const max = pointsCount ? Math.max(...values) : 0;
    if (pointsCount > 0) {
        const executionName = executionNameAccessor ? executionNameAccessor(executionOrder) : reportName;
        slices[executionId] = {
            min,
            max,
            metadata: {
                executionId,
                executionName,
            },
        };
    }
    return {
        type,
        dataType,
        mode,
        title,
        points,
        slices,
        series,
        min,
        max,
    };
};
export const mergeTrendDataGeneric = (trendData, trendDataPart, itemType) => {
    return {
        ...trendData,
        points: {
            ...trendData.points,
            ...trendDataPart.points,
        },
        slices: {
            ...trendData.slices,
            ...trendDataPart.slices,
        },
        series: Object.entries(trendDataPart.series).reduce((series, [group, pointIds]) => {
            if (Array.isArray(pointIds)) {
                return {
                    ...series,
                    [group]: [...(trendData.series?.[group] || []), ...pointIds],
                };
            }
            return series;
        }, trendData.series || createEmptySeries(itemType)),
        min: Math.min(trendData.min ?? Infinity, trendDataPart.min),
        max: Math.max(trendData.max ?? -Infinity, trendDataPart.max),
    };
};
export const generateTrendChartGeneric = (options, storeData, dataAccessor, reportName) => {
    const { limit } = options;
    const historyLimit = limit && limit > 0 ? Math.max(0, limit - 1) : undefined;
    const { historyDataPoints } = storeData;
    const currentData = dataAccessor.getCurrentData(storeData);
    const limitedHistoryPoints = historyLimit !== undefined ? historyDataPoints.slice(-historyLimit) : historyDataPoints;
    const firstOriginalIndex = historyLimit !== undefined ? Math.max(0, historyDataPoints.length - historyLimit) : 0;
    const convertedHistoryPoints = limitedHistoryPoints.map((point, index) => {
        const originalIndex = firstOriginalIndex + index;
        return {
            name: point.name,
            originalIndex,
            statistic: dataAccessor.getHistoricalData(point),
        };
    });
    const allValues = dataAccessor.getAllValues();
    const currentTrendData = getTrendDataGeneric(normalizeStatistic(currentData, allValues), reportName, historyDataPoints.length + 1, allValues, options);
    const historicalTrendData = convertedHistoryPoints.reduce((acc, historyPoint) => {
        const trendDataPart = getTrendDataGeneric(normalizeStatistic(historyPoint.statistic, allValues), historyPoint.name, historyPoint.originalIndex + 1, allValues, options);
        return mergeTrendDataGeneric(acc, trendDataPart, allValues);
    }, {
        type: options.type,
        dataType: options.dataType,
        mode: options.mode,
        title: options.title,
        points: {},
        slices: {},
        series: createEmptySeries(allValues),
        min: Infinity,
        max: -Infinity,
    });
    return mergeTrendDataGeneric(historicalTrendData, currentTrendData, allValues);
};
export const generateTrendChart = (options, storeData, reportName) => {
    const newOptions = { limit: DEFAULT_CHART_HISTORY_LIMIT, ...options };
    const { dataType } = newOptions;
    if (dataType === ChartDataType.Status) {
        return generateTrendChartGeneric(newOptions, storeData, statusTrendDataAccessor, reportName);
    }
    else if (dataType === ChartDataType.Severity) {
        return generateTrendChartGeneric(newOptions, storeData, severityTrendDataAccessor, reportName);
    }
};
