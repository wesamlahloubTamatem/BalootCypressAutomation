import { ChartType } from "@allurereport/charts-api";
import { coverageDiffTreeMapAccessor } from "./accessors/coverageDiffTreeMapAccessor.js";
import { successRateDistributionTreeMapAccessor } from "./accessors/successRateDistributionTreeMapAccessor.js";
export const convertTreeDataToTreeMapNode = (treeData, transform, transformRoot = () => ({
    id: "root",
    value: undefined,
})) => {
    const { root, leavesById, groupsById } = treeData;
    const convertNode = (nodeId, parentGroup, isGroup) => {
        const node = isGroup ? groupsById[nodeId] : leavesById[nodeId];
        if (!node) {
            return null;
        }
        const treeMapNode = transform(node, isGroup, parentGroup);
        if (isGroup) {
            const group = node;
            const children = [];
            if (group.groups) {
                group.groups.forEach((groupId) => {
                    const childNode = convertNode(groupId, group, true);
                    if (childNode) {
                        children.push(childNode);
                    }
                });
            }
            if (group.leaves) {
                group.leaves.forEach((leafId) => {
                    const childNode = convertNode(leafId, group, false);
                    if (childNode) {
                        children.push(childNode);
                    }
                });
            }
            if (children.length === 0) {
                return null;
            }
            treeMapNode.children = children;
        }
        return treeMapNode;
    };
    const rootChildren = [];
    if (root.groups) {
        root.groups.forEach((groupId) => {
            const childNode = convertNode(groupId, root, true);
            if (childNode) {
                rootChildren.push(childNode);
            }
        });
    }
    if (root.leaves) {
        root.leaves.forEach((leafId) => {
            const childNode = convertNode(leafId, root, false);
            if (childNode) {
                rootChildren.push(childNode);
            }
        });
    }
    return {
        children: rootChildren.length > 0 ? rootChildren : undefined,
        ...transformRoot(root),
    };
};
export const transformTreeMapNode = (tree, transform) => {
    const transformedNode = transform(tree);
    if (transformedNode.children) {
        const transformedChildren = transformedNode.children.map((child) => transformTreeMapNode(child, transform));
        return {
            ...transformedNode,
            children: transformedChildren,
        };
    }
    return transformedNode;
};
export const generateTreeMapChartGeneric = (options, storeData, dataAccessor) => ({
    type: options.type,
    title: options.title,
    treeMap: dataAccessor.getTreeMap(storeData),
});
export const generateTreeMapChart = (options, storeData) => {
    const { type } = options;
    if (type === ChartType.SuccessRateDistribution) {
        return generateTreeMapChartGeneric(options, storeData, successRateDistributionTreeMapAccessor);
    }
    else if (type === ChartType.CoverageDiff) {
        return generateTreeMapChartGeneric(options, storeData, coverageDiffTreeMapAccessor);
    }
};
