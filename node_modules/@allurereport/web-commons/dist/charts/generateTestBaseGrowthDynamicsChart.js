import { ChartType, DEFAULT_CHART_HISTORY_LIMIT } from "@allurereport/charts-api";
import { htrsByTr, statusesList } from "@allurereport/core-api";
import { limitHistoryDataPoints } from "./chart-utils.js";
const createEmptyStats = (statuses) => {
    return statuses.reduce((acc, status) => {
        acc[`new:${status}`] = 0;
        acc[`removed:${status}`] = 0;
        return acc;
    }, {});
};
const DEFAULT_STATUSES = [...statusesList];
export const generateTestBaseGrowthDynamicsChart = (props) => {
    const { options, storeData } = props;
    const { limit = DEFAULT_CHART_HISTORY_LIMIT, statuses = DEFAULT_STATUSES } = options;
    const { historyDataPoints, testResults } = storeData;
    const currentReportTimestamp = testResults.reduce((acc, testResult) => Math.max(acc, testResult.stop ?? 0), 0);
    const statusList = statuses.length > 0 ? statuses : DEFAULT_STATUSES;
    const limitedHistoryPoints = limitHistoryDataPoints(historyDataPoints, limit).sort((a, b) => a.timestamp - b.timestamp);
    if (limitedHistoryPoints.length === 0) {
        return {
            type: ChartType.TestBaseGrowthDynamics,
            title: options.title,
            data: [
                {
                    id: "current",
                    timestamp: currentReportTimestamp,
                    ...createEmptyStats(statusList),
                },
            ],
            statuses: statusList,
        };
    }
    const [earliestHdp, ...hdps] = limitedHistoryPoints;
    const dataPoints = [
        ...hdps.map((hdp) => ({
            ...hdp,
            stats: createEmptyStats(statusList),
        })),
        {
            testResults: testResults.reduce((acc, testResult) => {
                acc[testResult.historyId ?? testResult.id] = testResult;
                return acc;
            }, {}),
            uuid: "current",
            timestamp: currentReportTimestamp,
            stats: createEmptyStats(statusList),
        },
    ];
    dataPoints.forEach(({ testResults: trs, stats }, index) => {
        const isFirst = index === 0;
        const isLast = index === dataPoints.length - 1;
        const hpsPriorToCurrent = isFirst ? [earliestHdp] : dataPoints.slice(0, index);
        const hpsAfterCurrent = dataPoints.slice(index + 1);
        const currentTrs = Object.values(trs);
        for (const cTr of currentTrs) {
            if (!statusList.includes(cTr.status)) {
                continue;
            }
            const htrsPriortoCurr = htrsByTr(hpsPriorToCurrent, cTr);
            if (htrsPriortoCurr.length === 0) {
                stats[`new:${cTr.status}`]++;
            }
            if (isLast) {
                continue;
            }
            const htrsAfterCurrent = htrsByTr(hpsAfterCurrent, cTr);
            if (htrsAfterCurrent.length === 0) {
                stats[`removed:${cTr.status}`]++;
            }
        }
    });
    const data = dataPoints.map(({ uuid, timestamp, stats }) => ({ ...stats, id: uuid, timestamp }));
    return {
        type: ChartType.TestBaseGrowthDynamics,
        title: options.title,
        data: data,
        statuses: statusList,
    };
};
