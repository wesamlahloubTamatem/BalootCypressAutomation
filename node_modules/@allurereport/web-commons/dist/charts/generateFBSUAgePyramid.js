import { ChartType, DEFAULT_CHART_HISTORY_LIMIT } from "@allurereport/charts-api";
import { htrsByTr } from "@allurereport/core-api";
import { limitHistoryDataPoints } from "./chart-utils.js";
const createEmptyStats = (statuses) => {
    return statuses.reduce((acc, status) => {
        acc[status] = 0;
        return acc;
    }, {});
};
const STATUSES = ["failed", "broken", "skipped", "unknown"];
const isFBSUStatus = (status) => STATUSES.includes(status);
export const generateFBSUAgePyramid = (props) => {
    const { options, storeData } = props;
    const { limit = DEFAULT_CHART_HISTORY_LIMIT } = options;
    const { historyDataPoints, testResults } = storeData;
    const currentReportTimestamp = testResults.reduce((acc, testResult) => Math.max(acc, testResult.stop ?? 0), 0);
    const limitedHistoryPoints = limitHistoryDataPoints(historyDataPoints, limit).sort((a, b) => a.timestamp - b.timestamp);
    if (limitedHistoryPoints.length === 0) {
        return {
            type: ChartType.FBSUAgePyramid,
            title: options.title,
            data: [
                {
                    id: "current",
                    timestamp: currentReportTimestamp,
                    ...createEmptyStats(STATUSES),
                },
            ],
            statuses: STATUSES,
        };
    }
    const [earliestHdp, ...hdps] = limitedHistoryPoints;
    const dataPoints = [
        ...hdps.map((hdp) => ({
            ...hdp,
            ...createEmptyStats(STATUSES),
        })),
        {
            testResults: testResults.reduce((acc, testResult) => {
                acc[testResult.historyId ?? testResult.id] = testResult;
                return acc;
            }, {}),
            uuid: "current",
            timestamp: currentReportTimestamp,
            ...createEmptyStats(STATUSES),
        },
    ];
    dataPoints.forEach((dp, index, dataPointsAscending) => {
        const { testResults: trs } = dp;
        const isFirst = index === 0;
        const hpsPriorToCurrent = isFirst ? [earliestHdp] : dataPointsAscending.slice(0, index);
        const currentTrs = Object.values(trs);
        for (const cTr of currentTrs) {
            if (!isFBSUStatus(cTr.status)) {
                continue;
            }
            const htrsPriortoCurr = htrsByTr(hpsPriorToCurrent, cTr);
            if (htrsPriortoCurr.length === 0) {
                dp[cTr.status]++;
            }
        }
    });
    const data = dataPoints.map(({ uuid, timestamp, ...stats }) => ({
        id: uuid,
        timestamp,
        failed: stats.failed ?? 0,
        broken: stats.broken ?? 0,
        skipped: stats.skipped ?? 0,
        unknown: stats.unknown ?? 0,
    }));
    return {
        type: ChartType.FBSUAgePyramid,
        title: options.title,
        data: data,
        statuses: STATUSES,
    };
};
