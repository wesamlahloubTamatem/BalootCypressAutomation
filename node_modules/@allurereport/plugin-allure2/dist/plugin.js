var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Allure2Plugin_generate;
import { getWorstStatus } from "@allurereport/core-api";
import { convertToSummaryTestResult, preciseTreeLabels, } from "@allurereport/plugin-api";
import { convertTestResult } from "./converters.js";
import { generateAttachmentsData, generateCategoriesData, generateDefaultWidgetData, generateEmptyTrendData, generateEnvironmentJson, generateExecutorJson, generatePackagesData, generateStaticFiles, generateSummaryJson, generateTestResults, generateTimelineData, generateTree, generateTrendData, } from "./generators.js";
import { InMemoryReportDataWriter, ReportFileDataWriter } from "./writer.js";
export class Allure2Plugin {
    constructor(options = {}) {
        this.options = options;
        _Allure2Plugin_generate.set(this, async (context, store) => {
            const { reportName = "Allure Report", singleFile = false, reportLanguage = "en" } = this.options ?? {};
            const writer = singleFile ? new InMemoryReportDataWriter() : new ReportFileDataWriter(context.reportFiles);
            const attachmentLinks = await store.allAttachments();
            const attachmentMap = await generateAttachmentsData(writer, attachmentLinks, (id) => store.attachmentContentById(id));
            const categories = (await store.metadataByKey("allure2_categories")) ?? [];
            const environmentItems = (await store.metadataByKey("allure_environment")) ?? [];
            const tests = await store.allTestResults({ includeHidden: true });
            const allTr = [];
            for (const value of tests) {
                const fixtures = await store.fixturesByTrId(value.id);
                const retries = await store.retriesByTrId(value.id);
                const history = (await store.historyByTrId(value.id)) ?? [];
                const allure2TestResult = convertTestResult({
                    attachmentMap,
                    fixtures,
                    categories,
                    retries,
                    history,
                }, value);
                allTr.push(allure2TestResult);
            }
            await generateTestResults(writer, allTr);
            const displayedTr = allTr.filter((atr) => !atr.hidden);
            const treeLabelNamesFactory = (labelNames) => preciseTreeLabels(labelNames, displayedTr, (tr) => {
                if (tr.labels) {
                    return tr.labels.map(({ name }) => name);
                }
                return [];
            });
            await generateTree(writer, "suites", treeLabelNamesFactory(["parentSuite", "suite", "subSuite"]), displayedTr);
            await generateTree(writer, "behaviors", treeLabelNamesFactory(["epic", "feature", "story"]), displayedTr);
            await generatePackagesData(writer, displayedTr);
            await generateCategoriesData(writer, displayedTr);
            await generateTimelineData(writer, allTr);
            await generateSummaryJson(writer, reportName, displayedTr);
            await generateEnvironmentJson(writer, environmentItems);
            const executor = await store.metadataByKey("allure2_executor");
            const historyDataPoints = await store.allHistoryDataPoints();
            await generateExecutorJson(writer, executor);
            await generateDefaultWidgetData(writer, displayedTr, "duration.json", "status-chart.json", "severity.json");
            await generateTrendData(writer, reportName, displayedTr, historyDataPoints);
            await generateEmptyTrendData(writer, "duration-trend.json", "categories-trend.json", "retry-trend.json");
            const reportDataFiles = singleFile ? writer.reportFiles() : [];
            await generateStaticFiles({
                allureVersion: context.allureVersion,
                reportName,
                reportLanguage,
                singleFile,
                reportFiles: context.reportFiles,
                reportDataFiles,
                reportUuid: context.reportUuid,
            });
        });
        this.update = async (context, store) => {
            await __classPrivateFieldGet(this, _Allure2Plugin_generate, "f").call(this, context, store);
        };
        this.done = async (context, store) => {
            await this.update(context, store);
        };
    }
    async info(context, store) {
        const allTrs = await store.allTestResults();
        const newTrs = await store.allNewTestResults();
        const retryTrs = allTrs.filter((tr) => !!tr?.retries?.length);
        const flakyTrs = allTrs.filter((tr) => !!tr?.flaky);
        const duration = allTrs.reduce((acc, { duration: trDuration = 0 }) => acc + trDuration, 0);
        const worstStatus = getWorstStatus(allTrs.map(({ status }) => status));
        const createdAt = allTrs.reduce((acc, { stop }) => Math.max(acc, stop || 0), 0);
        return {
            name: this.options.reportName || context.reportName,
            stats: await store.testsStatistic(),
            status: worstStatus ?? "passed",
            duration,
            createdAt,
            plugin: "Allure2",
            newTests: newTrs.map(convertToSummaryTestResult),
            flakyTests: flakyTrs.map(convertToSummaryTestResult),
            retryTests: retryTrs.map(convertToSummaryTestResult),
            meta: {
                reportId: context.reportUuid,
                singleFile: this.options.singleFile ?? false,
                withTestResultsLinks: true,
            },
        };
    }
}
_Allure2Plugin_generate = new WeakMap();
