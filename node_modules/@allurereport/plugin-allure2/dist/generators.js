import { createBaseUrlScript, createFaviconLinkTag, createReportDataScript, createScriptTag, createStylesLinkTag, } from "@allurereport/core-api";
import Handlebars from "handlebars";
import { readFile } from "node:fs/promises";
import { createRequire } from "node:module";
import { basename, join } from "node:path";
import { byLabels, collapseTree, createTree, createWidget } from "./tree.js";
import { updateStatistic, updateTime } from "./utils.js";
const require = createRequire(import.meta.url);
const template = `<!DOCTYPE html>
<html dir="ltr" lang="{{reportLanguage}}">
<head>
    <meta charset="utf-8">
    <title>{{reportName}}</title>
    {{{ headTags }}}
</head>
<body>
    <svg id="__SVG_SPRITE_NODE__" aria-hidden="true" style="position: absolute; width: 0; height: 0"></svg>
    <div id="alert"></div>
    <div id="content">
        <span class="spinner">
            <span class="spinner__circle"></span>
        </span>
    </div>
    <div id="popup"></div>
    {{{ bodyTags }}}
    ${createBaseUrlScript()}
    {{#if analyticsEnable}}
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LNDJ3J7WT0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LNDJ3J7WT0', {
          'allureVersion': '{{allureVersion}}',
          'report':'classic',
          'reportUuid': '{{reportUuid}}',
          'single_file': '{{singleFile}}'
        });
    </script>
    {{/if}}
    <script>
      window.allureReportOptions = {{{ reportOptions }}};
    </script>
    {{{ reportFilesScript }}}
</body>
</html>
`;
export const readTemplateManifest = async (singleFileMode) => {
    const templateManifestSource = require.resolve(`@allurereport/web-allure2/dist/${singleFileMode ? "single" : "multi"}/manifest.json`);
    const templateManifest = await readFile(templateManifestSource, { encoding: "utf-8" });
    return JSON.parse(templateManifest);
};
export const readManifestEntry = async (options) => {
    const { fileName, singleFile, mimeType, inserter, reportFiles } = options;
    const filePath = require.resolve(join("@allurereport/web-allure2/dist", singleFile ? "single" : "multi", fileName));
    const scriptContentBuffer = await readFile(filePath);
    if (singleFile) {
        return inserter(`data:${mimeType};base64,${scriptContentBuffer.toString("base64")}`);
    }
    await reportFiles.addFile(fileName, scriptContentBuffer);
    return inserter(fileName);
};
export const generateStaticFiles = async (payload) => {
    const { reportName, reportLanguage, singleFile, reportFiles, reportDataFiles, reportUuid, allureVersion } = payload;
    const compile = Handlebars.compile(template);
    const manifest = await readTemplateManifest(singleFile);
    const headTags = [];
    const bodyTags = [];
    for (const key in manifest) {
        const fileName = manifest[key];
        const filePath = require.resolve(join("@allurereport/web-allure2/dist", singleFile ? "single" : "multi", fileName));
        if (key === "favicon.ico") {
            const tag = await readManifestEntry({
                fileName,
                singleFile,
                reportFiles,
                inserter: createFaviconLinkTag,
                mimeType: "image/x-icon",
            });
            headTags.push(tag);
            continue;
        }
        if (key === "main.css") {
            const tag = await readManifestEntry({
                fileName,
                singleFile,
                reportFiles,
                inserter: createStylesLinkTag,
                mimeType: "text/css",
            });
            headTags.push(tag);
            continue;
        }
        if (key === "main.js") {
            const tag = await readManifestEntry({
                fileName,
                singleFile,
                reportFiles,
                inserter: createScriptTag,
                mimeType: "text/javascript",
            });
            bodyTags.push(tag);
            continue;
        }
        if (singleFile) {
            continue;
        }
        const fileContent = await readFile(filePath);
        await reportFiles.addFile(basename(filePath), fileContent);
    }
    const reportOptions = {
        reportName: reportName ?? "Allure Report",
        reportLanguage: reportLanguage ?? "en",
        createdAt: Date.now(),
    };
    try {
        const html = compile({
            headTags: headTags.join("\n"),
            bodyTags: bodyTags.join("\n"),
            reportFilesScript: createReportDataScript(reportDataFiles),
            reportOptions: JSON.stringify(reportOptions),
            analyticsEnable: true,
            allureVersion,
            reportLanguage,
            reportUuid,
            reportName,
            singleFile,
        });
        await reportFiles.addFile("index.html", Buffer.from(html, "utf8"));
    }
    catch (err) {
        if (err instanceof RangeError) {
            console.error("The report is too large to be generated in the single file mode!");
            process.exit(1);
            return;
        }
        throw err;
    }
};
export const generateTree = async (writer, name, labelNames, tests) => {
    const fileName = `${name}.json`;
    const data = createTree(tests, byLabels(labelNames));
    await writer.writeData(fileName, data);
    const widgetData = createWidget(data);
    await writer.writeWidget(fileName, widgetData);
};
export const generatePackagesData = async (writer, tests) => {
    const classifier = (test) => {
        return (test.labels
            .find((label) => label.name === "package")
            ?.value?.split(".")
            ?.map((group) => ({
            groups: [group],
        })) ?? []);
    };
    const data = createTree(tests, classifier);
    const packagesData = collapseTree(data);
    await writer.writeData("packages.json", packagesData);
};
export const generateCategoriesData = async (writer, tests) => {
    const classifier = (test) => {
        const byMessage = { groups: [test.statusMessage ?? "No message"] };
        const categories = test.extra.categories;
        if (!categories || categories.length === 0) {
            return undefined;
        }
        const groups = categories.map((c) => c.name);
        return [{ groups }, byMessage];
    };
    const data = createTree(tests, classifier);
    const fileName = "categories.json";
    await writer.writeData(fileName, data);
    const widgetData = createWidget(data);
    await writer.writeWidget(fileName, widgetData);
};
export const generateTimelineData = async (writer, tests) => {
    const classifier = (test) => {
        return [{ groups: [test.hostId ?? "Default"] }, { groups: [test.threadId ?? "Default"] }];
    };
    const data = createTree(tests, classifier);
    await writer.writeData("timeline.json", data);
};
export const generateTestResults = async (writer, tests) => {
    for (const test of tests) {
        await writer.writeTestCase(test);
    }
};
export const generateSummaryJson = async (writer, reportName, tests) => {
    const statistic = { total: 0 };
    const time = {};
    tests
        .filter((test) => !test.hidden)
        .forEach((test) => {
        updateStatistic(statistic, test);
        updateTime(time, test);
    });
    const data = {
        reportName,
        statistic,
        time,
    };
    await writer.writeWidget("summary.json", data);
};
export const generateEnvironmentJson = async (writer, env) => {
    await writer.writeWidget("environment.json", env);
};
export const generateExecutorJson = async (writer, executor) => {
    await writer.writeWidget("executors.json", executor ? [executor] : []);
};
export const generateDefaultWidgetData = async (writer, tests, ...fileNames) => {
    const statusChartData = tests
        .filter((test) => !test.hidden)
        .map(({ uid, name, status, time, extra: { severity = "normal" } }) => {
        return {
            uid,
            name,
            status,
            time,
            severity,
        };
    });
    for (const fileName of fileNames) {
        await writer.writeWidget(fileName, statusChartData);
    }
};
export const generateEmptyTrendData = async (writer, ...fileNames) => {
    for (const fileName of fileNames) {
        await writer.writeWidget(fileName, [
            {
                uid: "invalid",
                name: "invalid",
                statistic: { total: 0 },
            },
        ]);
    }
};
export const generateTrendData = async (writer, reportName, tests, historyDataPoints) => {
    const statistic = { total: 0 };
    tests
        .filter((test) => !test.hidden)
        .forEach((test) => {
        updateStatistic(statistic, test);
    });
    const history = historyDataPoints.map((point) => {
        const stat = { total: 0 };
        Object.values(point.testResults).forEach((testResult) => {
            updateStatistic(stat, testResult);
        });
        return {
            data: stat,
            timestamp: point.timestamp,
            reportName: point.name,
        };
    });
    history
        .sort((a, b) => b.timestamp - a.timestamp)
        .forEach((element, index) => {
        element.buildOrder = history.length - index;
    });
    const data = [
        {
            data: statistic,
            timestamp: new Date().getTime(),
            buildOrder: history.length + 1,
            reportName: reportName,
        },
        ...history,
    ];
    await writer.writeWidget("history-trend.json", data);
};
export const generateAttachmentsData = async (writer, attachmentLinks, contentFunction) => {
    const result = new Map();
    for (const { id, ext, ...link } of attachmentLinks) {
        if (link.missed) {
            continue;
        }
        const content = await contentFunction(id);
        if (!content) {
            continue;
        }
        const src = `${id}${ext}`;
        await writer.writeAttachment(src, content);
        result.set(id, src);
    }
    return result;
};
