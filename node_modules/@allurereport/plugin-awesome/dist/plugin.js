var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _AwesomePlugin_writer, _AwesomePlugin_generate;
import { getWorstStatus } from "@allurereport/core-api";
import { convertToSummaryTestResult, } from "@allurereport/plugin-api";
import { preciseTreeLabels } from "@allurereport/plugin-api";
import { join } from "node:path";
import { filterEnv } from "./environments.js";
import { generateTimeline } from "./generateTimeline.js";
import { generateAllCharts, generateAttachmentsFiles, generateEnvironmentJson, generateEnvirontmentsList, generateGlobals, generateHistoryDataPoints, generateNav, generateQualityGateResults, generateStaticFiles, generateStatistic, generateTestCases, generateTestEnvGroups, generateTestResults, generateTree, generateVariables, } from "./generators.js";
import { InMemoryReportDataWriter, ReportFileDataWriter } from "./writer.js";
export class AwesomePlugin {
    constructor(options = {}) {
        this.options = options;
        _AwesomePlugin_writer.set(this, void 0);
        _AwesomePlugin_generate.set(this, async (context, store) => {
            const { singleFile, groupBy = [], filter, appendTitlePath } = this.options ?? {};
            const environmentItems = await store.metadataByKey("allure_environment");
            const reportEnvironments = await store.allEnvironments();
            const attachments = await store.allAttachments();
            const allTrs = await store.allTestResults({ includeHidden: true });
            const statistics = await store.testsStatistic(filter);
            const environments = await store.allEnvironments();
            const envStatistics = new Map();
            const allTestEnvGroups = await store.allTestEnvGroups();
            const globalAttachments = await store.allGlobalAttachments();
            const globalExitCode = await store.globalExitCode();
            const globalErrors = await store.allGlobalErrors();
            const qualityGateResults = await store.qualityGateResults();
            for (const env of environments) {
                envStatistics.set(env, await store.testsStatistic(filterEnv(env, filter)));
            }
            await generateStatistic(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), {
                stats: statistics,
                statsByEnv: envStatistics,
                envs: environments,
            });
            await generateAllCharts(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), store, this.options, context);
            await generateTimeline(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), store, this.options);
            const convertedTrs = await generateTestResults(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), store, allTrs, this.options.filter);
            const hasGroupBy = groupBy.length > 0;
            const treeLabels = hasGroupBy
                ? preciseTreeLabels(groupBy, convertedTrs, ({ labels }) => labels.map(({ name }) => name))
                : [];
            await generateHistoryDataPoints(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), store);
            await generateTestCases(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), convertedTrs);
            await generateTree(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), "tree.json", treeLabels, convertedTrs, { appendTitlePath });
            await generateNav(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), convertedTrs, "nav.json");
            await generateTestEnvGroups(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), allTestEnvGroups);
            for (const reportEnvironment of reportEnvironments) {
                const envConvertedTrs = convertedTrs.filter(({ environment }) => environment === reportEnvironment);
                await generateTree(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), join(reportEnvironment, "tree.json"), treeLabels, envConvertedTrs, {
                    appendTitlePath,
                });
                await generateNav(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), envConvertedTrs, join(reportEnvironment, "nav.json"));
            }
            await generateEnvirontmentsList(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), store);
            await generateVariables(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), store);
            if (environmentItems?.length) {
                await generateEnvironmentJson(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), environmentItems);
            }
            if (attachments?.length) {
                await generateAttachmentsFiles(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), attachments, (id) => store.attachmentContentById(id));
            }
            await generateQualityGateResults(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), qualityGateResults);
            await generateGlobals(__classPrivateFieldGet(this, _AwesomePlugin_writer, "f"), {
                globalAttachments,
                globalErrors,
                globalExitCode,
                contentFunction: (id) => store.attachmentContentById(id),
            });
            const reportDataFiles = singleFile ? __classPrivateFieldGet(this, _AwesomePlugin_writer, "f").reportFiles() : [];
            await generateStaticFiles({
                ...this.options,
                id: context.id,
                allureVersion: context.allureVersion,
                reportFiles: context.reportFiles,
                reportUuid: context.reportUuid,
                reportName: context.reportName,
                ci: context.ci,
                reportDataFiles,
            });
        });
        this.start = async (context) => {
            const { singleFile } = this.options;
            if (singleFile) {
                __classPrivateFieldSet(this, _AwesomePlugin_writer, new InMemoryReportDataWriter(), "f");
                return;
            }
            __classPrivateFieldSet(this, _AwesomePlugin_writer, new ReportFileDataWriter(context.reportFiles), "f");
            await Promise.resolve();
        };
        this.update = async (context, store) => {
            if (!__classPrivateFieldGet(this, _AwesomePlugin_writer, "f")) {
                throw new Error("call start first");
            }
            await __classPrivateFieldGet(this, _AwesomePlugin_generate, "f").call(this, context, store);
        };
        this.done = async (context, store) => {
            if (!__classPrivateFieldGet(this, _AwesomePlugin_writer, "f")) {
                throw new Error("call start first");
            }
            await __classPrivateFieldGet(this, _AwesomePlugin_generate, "f").call(this, context, store);
        };
    }
    async info(context, store) {
        const allTrs = (await store.allTestResults()).filter((tr) => this.options.filter ? this.options.filter(tr) : true);
        const newTrs = await store.allNewTestResults();
        const retryTrs = allTrs.filter((tr) => !!tr?.retries?.length);
        const flakyTrs = allTrs.filter((tr) => !!tr?.flaky);
        const duration = allTrs.reduce((acc, { duration: trDuration = 0 }) => acc + trDuration, 0);
        const worstStatus = getWorstStatus(allTrs.map(({ status }) => status));
        const createdAt = allTrs.reduce((acc, { stop }) => Math.max(acc, stop || 0), 0);
        return {
            name: this.options.reportName || context.reportName,
            stats: await store.testsStatistic(this.options.filter),
            status: worstStatus ?? "passed",
            duration,
            createdAt,
            plugin: "Awesome",
            newTests: newTrs.map(convertToSummaryTestResult),
            flakyTests: flakyTrs.map(convertToSummaryTestResult),
            retryTests: retryTrs.map(convertToSummaryTestResult),
            meta: {
                reportId: context.reportUuid,
                singleFile: this.options.singleFile ?? false,
                withTestResultsLinks: true,
            },
        };
    }
}
_AwesomePlugin_writer = new WeakMap(), _AwesomePlugin_generate = new WeakMap();
