import type { HistoryDataPoint, SeverityLevel, Statistic, TestResult, TestStatus } from "@allurereport/core-api";
export declare enum ChartType {
    CurrentStatus = "currentStatus",
    StatusDynamics = "statusDynamics",
    StatusTransitions = "statusTransitions",
    StabilityDistribution = "stabilityDistribution",
    TestBaseGrowthDynamics = "testBaseGrowthDynamics",
    FBSUAgePyramid = "fbsuAgePyramid",
    Durations = "durations",
    DurationDynamics = "durationDynamics",
    TrSeverities = "testResultSeverities",
    TestingPyramid = "testingPyramid",
    CoverageDiff = "coverageDiff",
    SuccessRateDistribution = "successRateDistribution",
    ProblemsDistribution = "problemsDistribution"
}
export declare enum ChartDataType {
    Status = "status",
    Severity = "severity"
}
export declare enum ChartMode {
    Raw = "raw",
    Percent = "percent",
    Diverging = "diverging"
}
export type ChartId = string;
export type TrendPointId = string;
export type TrendSliceId = string;
export type BaseMetadata = Record<string, unknown>;
export interface BaseTrendSliceMetadata extends BaseMetadata {
    executionId: string;
    executionName?: string;
}
export interface TrendPoint {
    x: string;
    y: number;
}
export type TrendSliceMetadata<Metadata extends BaseMetadata> = BaseTrendSliceMetadata & Metadata;
export interface TrendSlice<Metadata extends BaseTrendSliceMetadata = BaseTrendSliceMetadata> {
    min: number;
    max: number;
    metadata: TrendSliceMetadata<Metadata>;
}
export type PieSliceStatus = TestStatus | "__empty__";
export interface BasePieSlice {
    status: PieSliceStatus;
    count: number;
}
export interface PieSlice extends BasePieSlice {
    d: string | null;
}
export type PieChartValues = {
    percentage: number;
    slices: PieSlice[];
};
export type TreeMapNode<T extends Record<string, any> = {}> = T & {
    id: string;
    value?: number;
    colorValue?: number;
    children?: TreeMapNode<T>[];
};
export type HeatMapPoint = {
    x: string;
    y?: number;
};
export type HeatMapSerie<T extends Record<string, any> = Record<string, any>> = {
    id: string;
    data: HeatMapPoint[];
} & T;
export type ExecutionIdFn = (executionOrder: number) => string;
export type ExecutionNameFn = (executionOrder: number) => string;
export type TrendMetadataFnOverrides = {
    executionIdAccessor?: ExecutionIdFn;
    executionNameAccessor?: ExecutionNameFn;
};
export type TrendDataType = TestStatus | SeverityLevel;
export type TrendStats<T extends TrendDataType> = Record<T, number>;
export type TrendCalculationResult<T extends TrendDataType> = {
    points: Record<TrendPointId, TrendPoint>;
    series: Record<T, TrendPointId[]>;
};
export interface GenericTrendChartData<SeriesType extends string, Metadata extends BaseTrendSliceMetadata = BaseTrendSliceMetadata> {
    type: "trend";
    dataType: ChartDataType;
    mode: ChartMode;
    title?: string;
    points: Record<TrendPointId, TrendPoint>;
    slices: Record<TrendSliceId, TrendSlice<Metadata>>;
    series: Record<SeriesType, TrendPointId[]>;
    min: number;
    max: number;
}
export type StatusTrendChartData = GenericTrendChartData<TestStatus>;
export type SeverityTrendChartData = GenericTrendChartData<SeverityLevel>;
export type TrendChartData = StatusTrendChartData | SeverityTrendChartData;
export interface TreeMapChartData {
    type: ChartType.CoverageDiff | ChartType.SuccessRateDistribution;
    title?: string;
    treeMap: TreeMapNode;
}
export interface HeatMapChartData<T extends Record<string, any> = {}> {
    type: ChartType.ProblemsDistribution;
    title?: string;
    data: HeatMapSerie<T>[];
}
export interface TestingPyramidChartData {
    type: ChartType.TestingPyramid;
    title?: string;
    data: {
        layer: string;
        testCount: number;
        successRate: number;
        percentage: number;
    }[];
}
export interface CurrentStatusChartData {
    type: ChartType.CurrentStatus;
    title?: string;
    data: Statistic;
}
export interface StatusDynamicsChartData {
    type: ChartType.StatusDynamics;
    title?: string;
    data: {
        statistic: Statistic;
        id: string;
        timestamp: number;
        name: string;
    }[];
    limit?: number;
    statuses?: TestStatus[];
}
export interface StatusTransitionsChartData {
    type: ChartType.StatusTransitions;
    title?: string;
    data: {
        id: string | "current";
        timestamp: number;
        prevItemTimestamp: number;
        fixed: number;
        regressed: number;
        malfunctioned: number;
    }[];
}
export interface DurationsChartData {
    type: ChartType.Durations;
    title?: string;
    data: {
        from: number;
        to: number;
        [key: string]: number;
    }[];
    keys: {
        [id: string]: string;
    };
    groupBy: "layer" | "none";
}
export interface StabilityDistributionChartData {
    type: ChartType.StabilityDistribution;
    title?: string;
    data: {
        id: string;
        stabilityRate: number;
    }[];
    keys: {
        [id: string]: string;
    };
    threshold?: number;
}
export interface TestBaseGrowthDynamicsChartData {
    type: ChartType.TestBaseGrowthDynamics;
    title?: string;
    data: ({
        [key in `new:${TestStatus}` | `removed:${TestStatus}`]: number;
    } & {
        id: string;
        timestamp: number;
    })[];
    statuses: TestStatus[];
}
export interface FBSUAgePyramidChartData {
    type: ChartType.FBSUAgePyramid;
    title?: string;
    data: {
        id: string;
        timestamp: number;
        failed: number;
        broken: number;
        skipped: number;
        unknown: number;
    }[];
    statuses: Exclude<TestStatus, "passed">[];
}
export type TrSeveritiesChartData = {
    type: ChartType.TrSeverities;
    title?: string;
    data: ({
        id: SeverityLevel | "unset";
    } & Record<TestStatus, number>)[];
    levels: (SeverityLevel | "unset")[];
    statuses: TestStatus[];
};
export type DurationDynamicsChartData = {
    type: ChartType.DurationDynamics;
    title?: string;
    data: {
        id: string;
        timestamp: number;
        duration: number;
        sequentialDuration: number;
        speedup: number;
    }[];
};
export type GeneratedChartData = TrendChartData | CurrentStatusChartData | StatusDynamicsChartData | StatusTransitionsChartData | DurationsChartData | StabilityDistributionChartData | TestBaseGrowthDynamicsChartData | FBSUAgePyramidChartData | TreeMapChartData | HeatMapChartData | TestingPyramidChartData | TrSeveritiesChartData | DurationDynamicsChartData;
export type GeneratedChartsData = Record<ChartId, GeneratedChartData>;
export type CurrentStatusChartOptions = {
    type: ChartType.CurrentStatus;
    title?: string;
    statuses?: TestStatus[];
    metric?: TestStatus;
};
export type StatusDynamicsChartOptions = {
    type: ChartType.StatusDynamics;
    title?: string;
    limit?: number;
    statuses?: TestStatus[];
};
export type StatusTransitionsChartOptions = {
    type: ChartType.StatusTransitions;
    title?: string;
    limit?: number;
};
export type DurationsChartOptions = {
    type: ChartType.Durations;
    title?: string;
    groupBy?: "layer" | "none";
};
export type StabilityDistributionChartOptions = {
    type: ChartType.StabilityDistribution;
    title?: string;
    threshold?: number;
    skipStatuses?: TestStatus[];
    groupBy?: "feature" | "epic" | "story" | "suite" | "severity" | "owner" | `label-name:${string}`;
    groupValues?: string[];
};
export type TestBaseGrowthDynamicsChartOptions = {
    type: ChartType.TestBaseGrowthDynamics;
    title?: string;
    statuses?: TestStatus[];
    limit?: number;
};
export type FBSUAgePyramidChartOptions = {
    type: ChartType.FBSUAgePyramid;
    title?: string;
    limit?: number;
};
export type TrSeveritiesChartOptions = {
    type: ChartType.TrSeverities;
    title?: string;
    levels?: SeverityLevel[];
    statuses?: TestStatus[];
    includeUnset?: boolean;
};
export type DurationDynamicsChartOptions = {
    type: ChartType.DurationDynamics;
    title?: string;
    limit?: number;
};
export type TreeMapChartOptions = {
    type: ChartType.CoverageDiff | ChartType.SuccessRateDistribution;
    title?: string;
};
export type HeatMapChartOptions = {
    type: ChartType.ProblemsDistribution;
    by: "environment";
    title?: string;
};
export type TestingPyramidChartOptions = {
    type: ChartType.TestingPyramid;
    title?: string;
    layers?: string[];
};
export type ChartOptions = CurrentStatusChartOptions | StatusDynamicsChartOptions | DurationsChartOptions | TreeMapChartOptions | HeatMapChartOptions | TestingPyramidChartOptions | StatusTransitionsChartOptions | StabilityDistributionChartOptions | FBSUAgePyramidChartOptions | TestBaseGrowthDynamicsChartOptions | TrSeveritiesChartOptions | DurationDynamicsChartOptions;
export interface AllureChartsStoreData {
    historyDataPoints: HistoryDataPoint[];
    testResults: TestResult[];
    statistic: Statistic;
}
export interface TrendDataAccessor<T extends TrendDataType> {
    getCurrentData: (storeData: AllureChartsStoreData) => TrendStats<T>;
    getHistoricalData: (historyPoint: HistoryDataPoint) => TrendStats<T>;
    getAllValues: () => readonly T[];
}
export interface TreeMapDataAccessor<T extends TreeMapNode> {
    getTreeMap: (storeData: AllureChartsStoreData) => T;
}
export interface HeatMapDataAccessor<T extends Record<string, unknown> = {}> {
    getHeatMap: (storeData: AllureChartsStoreData) => HeatMapSerie<T>[];
}
