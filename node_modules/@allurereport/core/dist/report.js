var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AllureReport_instances, _AllureReport_reportName, _AllureReport_reportVariables, _AllureReport_ci, _AllureReport_store, _AllureReport_readers, _AllureReport_plugins, _AllureReport_reportFiles, _AllureReport_eventEmitter, _AllureReport_realtimeSubscriber, _AllureReport_realtimeDispatcher, _AllureReport_realTime, _AllureReport_output, _AllureReport_history, _AllureReport_allureServiceClient, _AllureReport_qualityGate, _AllureReport_stage, _AllureReport_stageTempDirs, _AllureReport_state, _AllureReport_executionStage, _AllureReport_publish_get, _AllureReport_update, _AllureReport_eachPlugin, _AllureReport_getPluginState;
import { detect } from "@allurereport/ci";
import { AllureStoreDumpFiles, } from "@allurereport/plugin-api";
import { allure1, allure2, attachments, cucumberjson, junitXml, readXcResultBundle } from "@allurereport/reader";
import { PathResultFile } from "@allurereport/reader-api";
import { AllureRemoteHistory, AllureServiceClient, KnownError, UnknownError } from "@allurereport/service";
import { generateSummary } from "@allurereport/summary";
import ZipReadStream from "node-stream-zip";
import console from "node:console";
import { randomUUID } from "node:crypto";
import { EventEmitter } from "node:events";
import { createReadStream, createWriteStream, existsSync, readFileSync } from "node:fs";
import { lstat, mkdtemp, opendir, readdir, realpath, rename, rm, writeFile } from "node:fs/promises";
import { tmpdir } from "node:os";
import { basename, dirname, join, resolve } from "node:path";
import { promisify } from "node:util";
import pLimit from "p-limit";
import ProgressBar from "progress";
import ZipWriteStream from "zip-stream";
import { AllureLocalHistory, createHistory } from "./history.js";
import { DefaultPluginState, PluginFiles } from "./plugin.js";
import { QualityGate } from "./qualityGate/index.js";
import { DefaultAllureStore } from "./store/store.js";
import { RealtimeEventsDispatcher, RealtimeSubscriber } from "./utils/event.js";
const { version } = JSON.parse(readFileSync(new URL("../package.json", import.meta.url), "utf8"));
const initRequired = "report is not initialised. Call the start() method first.";
export class AllureReport {
    constructor(opts) {
        _AllureReport_instances.add(this);
        _AllureReport_reportName.set(this, void 0);
        _AllureReport_reportVariables.set(this, void 0);
        _AllureReport_ci.set(this, void 0);
        _AllureReport_store.set(this, void 0);
        _AllureReport_readers.set(this, void 0);
        _AllureReport_plugins.set(this, void 0);
        _AllureReport_reportFiles.set(this, void 0);
        _AllureReport_eventEmitter.set(this, void 0);
        _AllureReport_realtimeSubscriber.set(this, void 0);
        _AllureReport_realtimeDispatcher.set(this, void 0);
        _AllureReport_realTime.set(this, void 0);
        _AllureReport_output.set(this, void 0);
        _AllureReport_history.set(this, void 0);
        _AllureReport_allureServiceClient.set(this, void 0);
        _AllureReport_qualityGate.set(this, void 0);
        _AllureReport_stage.set(this, void 0);
        _AllureReport_stageTempDirs.set(this, []);
        _AllureReport_state.set(this, void 0);
        _AllureReport_executionStage.set(this, "init");
        this.readDirectory = async (resultsDir) => {
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") !== "running") {
                throw new Error(initRequired);
            }
            const resultsDirPath = resolve(resultsDir);
            if (await readXcResultBundle(__classPrivateFieldGet(this, _AllureReport_store, "f"), resultsDirPath)) {
                return;
            }
            const dir = await opendir(resultsDirPath);
            try {
                for await (const dirent of dir) {
                    if (dirent.isFile()) {
                        const path = await realpath(join(dirent.parentPath ?? dirent.path, dirent.name));
                        await this.readResult(new PathResultFile(path, dirent.name));
                    }
                }
            }
            catch (e) {
                console.error("can't read directory", e);
            }
        };
        this.readFile = async (resultsFile) => {
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") !== "running") {
                throw new Error(initRequired);
            }
            await this.readResult(new PathResultFile(resultsFile));
        };
        this.readResult = async (data) => {
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") !== "running") {
                throw new Error(initRequired);
            }
            for (const reader of __classPrivateFieldGet(this, _AllureReport_readers, "f")) {
                try {
                    const processed = await reader.read(__classPrivateFieldGet(this, _AllureReport_store, "f"), data);
                    if (processed) {
                        return;
                    }
                }
                catch (ignored) { }
            }
        };
        this.validate = async (params) => {
            const { trs, knownIssues, state } = params;
            return __classPrivateFieldGet(this, _AllureReport_qualityGate, "f").validate({
                trs: trs.filter(Boolean),
                knownIssues,
                state,
            });
        };
        this.start = async () => {
            const branch = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.jobRunBranch;
            await __classPrivateFieldGet(this, _AllureReport_store, "f").readHistory();
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") === "running") {
                throw new Error("the report is already started");
            }
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") === "done") {
                throw new Error("the report is already stopped, the restart isn't supported at the moment");
            }
            __classPrivateFieldSet(this, _AllureReport_executionStage, "running", "f");
            if (__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f") && __classPrivateFieldGet(this, _AllureReport_instances, "a", _AllureReport_publish_get) && branch) {
                const { url } = await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").createReport({
                    reportUuid: this.reportUuid,
                    reportName: __classPrivateFieldGet(this, _AllureReport_reportName, "f"),
                    branch,
                });
                this.reportUrl = url;
            }
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, true, async (plugin, context) => {
                await plugin.start?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"), __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f"));
            });
            if (__classPrivateFieldGet(this, _AllureReport_realTime, "f")) {
                await __classPrivateFieldGet(this, _AllureReport_update, "f").call(this);
                __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f").onAll(async () => {
                    await __classPrivateFieldGet(this, _AllureReport_update, "f").call(this);
                });
            }
        };
        _AllureReport_update.set(this, async () => {
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") !== "running") {
                return;
            }
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, false, async (plugin, context) => {
                await plugin.update?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"));
            });
        });
        this.dumpState = async () => {
            const { testResults, testCases, fixtures, attachments: attachmentsLinks, environments, globalAttachments = [], globalErrors = [], indexAttachmentByTestResult = {}, indexTestResultByHistoryId = {}, indexTestResultByTestCase = {}, indexLatestEnvTestResultByHistoryId = {}, indexAttachmentByFixture = {}, indexFixturesByTestResult = {}, indexKnownByHistoryId = {}, qualityGateResultsByRules = {}, } = __classPrivateFieldGet(this, _AllureReport_store, "f").dumpState();
            const allAttachments = await __classPrivateFieldGet(this, _AllureReport_store, "f").allAttachments();
            const dumpArchive = new ZipWriteStream({
                zlib: { level: 5 },
            });
            const addEntry = promisify(dumpArchive.entry.bind(dumpArchive));
            const dumpArchiveWriteStream = createWriteStream(`${__classPrivateFieldGet(this, _AllureReport_stage, "f")}.zip`);
            const promise = new Promise((res, rej) => {
                dumpArchive.on("error", (err) => rej(err));
                dumpArchiveWriteStream.on("finish", () => res(void 0));
                dumpArchiveWriteStream.on("error", (err) => rej(err));
            });
            dumpArchive.pipe(dumpArchiveWriteStream);
            await addEntry(Buffer.from(JSON.stringify(testResults)), {
                name: AllureStoreDumpFiles.TestResults,
            });
            await addEntry(Buffer.from(JSON.stringify(testCases)), {
                name: AllureStoreDumpFiles.TestCases,
            });
            await addEntry(Buffer.from(JSON.stringify(fixtures)), {
                name: AllureStoreDumpFiles.Fixtures,
            });
            await addEntry(Buffer.from(JSON.stringify(attachmentsLinks)), {
                name: AllureStoreDumpFiles.Attachments,
            });
            await addEntry(Buffer.from(JSON.stringify(environments)), {
                name: AllureStoreDumpFiles.Environments,
            });
            await addEntry(Buffer.from(JSON.stringify(__classPrivateFieldGet(this, _AllureReport_reportVariables, "f"))), {
                name: AllureStoreDumpFiles.ReportVariables,
            });
            await addEntry(Buffer.from(JSON.stringify(globalAttachments)), {
                name: AllureStoreDumpFiles.GlobalAttachments,
            });
            await addEntry(Buffer.from(JSON.stringify(globalErrors)), {
                name: AllureStoreDumpFiles.GlobalErrors,
            });
            await addEntry(Buffer.from(JSON.stringify(indexAttachmentByTestResult)), {
                name: AllureStoreDumpFiles.IndexAttachmentsByTestResults,
            });
            await addEntry(Buffer.from(JSON.stringify(indexTestResultByHistoryId)), {
                name: AllureStoreDumpFiles.IndexTestResultsByHistoryId,
            });
            await addEntry(Buffer.from(JSON.stringify(indexTestResultByTestCase)), {
                name: AllureStoreDumpFiles.IndexTestResultsByTestCase,
            });
            await addEntry(Buffer.from(JSON.stringify(indexLatestEnvTestResultByHistoryId)), {
                name: AllureStoreDumpFiles.IndexLatestEnvTestResultsByHistoryId,
            });
            await addEntry(Buffer.from(JSON.stringify(indexAttachmentByFixture)), {
                name: AllureStoreDumpFiles.IndexAttachmentsByFixture,
            });
            await addEntry(Buffer.from(JSON.stringify(indexFixturesByTestResult)), {
                name: AllureStoreDumpFiles.IndexFixturesByTestResult,
            });
            await addEntry(Buffer.from(JSON.stringify(indexKnownByHistoryId)), {
                name: AllureStoreDumpFiles.IndexKnownByHistoryId,
            });
            await addEntry(Buffer.from(JSON.stringify(qualityGateResultsByRules)), {
                name: AllureStoreDumpFiles.QualityGateResultsByRules,
            });
            for (const attachment of allAttachments) {
                const content = await __classPrivateFieldGet(this, _AllureReport_store, "f").attachmentContentById(attachment.id);
                if (!content) {
                    continue;
                }
                if (content instanceof PathResultFile) {
                    await addEntry(createReadStream(content.path), {
                        name: attachment.id,
                    });
                }
                else {
                    await addEntry(await content.asBuffer(), {
                        name: attachment.id,
                    });
                }
            }
            dumpArchive.finalize();
            return promise;
        };
        this.restoreState = async (stages) => {
            for (const stage of stages) {
                if (!existsSync(stage)) {
                    continue;
                }
                const dump = new ZipReadStream.async({
                    file: stage,
                });
                const testResultsEntry = await dump.entryData(AllureStoreDumpFiles.TestResults);
                const testCasesEntry = await dump.entryData(AllureStoreDumpFiles.TestCases);
                const fixturesEntry = await dump.entryData(AllureStoreDumpFiles.Fixtures);
                const attachmentsEntry = await dump.entryData(AllureStoreDumpFiles.Attachments);
                const environmentsEntry = await dump.entryData(AllureStoreDumpFiles.Environments);
                const reportVariablesEntry = await dump.entryData(AllureStoreDumpFiles.ReportVariables);
                const globalAttachmentsEntry = await dump.entryData(AllureStoreDumpFiles.GlobalAttachments);
                const globalErrorsEntry = await dump.entryData(AllureStoreDumpFiles.GlobalErrors);
                const indexAttachmentsEntry = await dump.entryData(AllureStoreDumpFiles.IndexAttachmentsByTestResults);
                const indexTestResultsByHistoryId = await dump.entryData(AllureStoreDumpFiles.IndexTestResultsByHistoryId);
                const indexTestResultsByTestCaseEntry = await dump.entryData(AllureStoreDumpFiles.IndexTestResultsByTestCase);
                const indexLatestEnvTestResultsByHistoryIdEntry = await dump.entryData(AllureStoreDumpFiles.IndexLatestEnvTestResultsByHistoryId);
                const indexAttachmentsByFixtureEntry = await dump.entryData(AllureStoreDumpFiles.IndexAttachmentsByFixture);
                const indexFixturesByTestResultEntry = await dump.entryData(AllureStoreDumpFiles.IndexFixturesByTestResult);
                const indexKnownByHistoryIdEntry = await dump.entryData(AllureStoreDumpFiles.IndexKnownByHistoryId);
                const qualityGateResultsByRulesEntry = await dump.entryData(AllureStoreDumpFiles.QualityGateResultsByRules);
                const attachmentsEntries = Object.entries(await dump.entries()).reduce((acc, [entryName, entry]) => {
                    switch (entryName) {
                        case AllureStoreDumpFiles.Attachments:
                        case AllureStoreDumpFiles.TestResults:
                        case AllureStoreDumpFiles.TestCases:
                        case AllureStoreDumpFiles.Fixtures:
                        case AllureStoreDumpFiles.Environments:
                        case AllureStoreDumpFiles.ReportVariables:
                        case AllureStoreDumpFiles.GlobalAttachments:
                        case AllureStoreDumpFiles.GlobalErrors:
                        case AllureStoreDumpFiles.IndexAttachmentsByTestResults:
                        case AllureStoreDumpFiles.IndexTestResultsByHistoryId:
                        case AllureStoreDumpFiles.IndexTestResultsByTestCase:
                        case AllureStoreDumpFiles.IndexLatestEnvTestResultsByHistoryId:
                        case AllureStoreDumpFiles.IndexAttachmentsByFixture:
                        case AllureStoreDumpFiles.IndexFixturesByTestResult:
                        case AllureStoreDumpFiles.IndexKnownByHistoryId:
                        case AllureStoreDumpFiles.QualityGateResultsByRules:
                            return acc;
                        default:
                            return Object.assign(acc, {
                                [entryName]: entry,
                            });
                    }
                }, {});
                const dumpState = {
                    testResults: JSON.parse(testResultsEntry.toString("utf8")),
                    testCases: JSON.parse(testCasesEntry.toString("utf8")),
                    fixtures: JSON.parse(fixturesEntry.toString("utf8")),
                    attachments: JSON.parse(attachmentsEntry.toString("utf8")),
                    environments: JSON.parse(environmentsEntry.toString("utf8")),
                    reportVariables: JSON.parse(reportVariablesEntry.toString("utf8")),
                    globalAttachments: JSON.parse(globalAttachmentsEntry.toString("utf8")),
                    globalErrors: JSON.parse(globalErrorsEntry.toString("utf8")),
                    indexAttachmentByTestResult: JSON.parse(indexAttachmentsEntry.toString("utf8")),
                    indexTestResultByHistoryId: JSON.parse(indexTestResultsByHistoryId.toString("utf8")),
                    indexTestResultByTestCase: JSON.parse(indexTestResultsByTestCaseEntry.toString("utf8")),
                    indexLatestEnvTestResultByHistoryId: JSON.parse(indexLatestEnvTestResultsByHistoryIdEntry.toString("utf8")),
                    indexAttachmentByFixture: JSON.parse(indexAttachmentsByFixtureEntry.toString("utf8")),
                    indexFixturesByTestResult: JSON.parse(indexFixturesByTestResultEntry.toString("utf8")),
                    indexKnownByHistoryId: JSON.parse(indexKnownByHistoryIdEntry.toString("utf8")),
                    qualityGateResultsByRules: JSON.parse(qualityGateResultsByRulesEntry.toString("utf8")),
                };
                const stageTempDir = await mkdtemp(join(tmpdir(), basename(stage, ".zip")));
                const resultsAttachments = {};
                __classPrivateFieldGet(this, _AllureReport_stageTempDirs, "f").push(stageTempDir);
                try {
                    for (const [attachmentId] of Object.entries(attachmentsEntries)) {
                        const attachmentContentEntry = await dump.entryData(attachmentId);
                        const attachmentFilePath = join(stageTempDir, attachmentId);
                        await writeFile(attachmentFilePath, attachmentContentEntry);
                        resultsAttachments[attachmentId] = new PathResultFile(attachmentFilePath, attachmentId);
                    }
                }
                catch (err) {
                    console.error(`Can't restore state from "${stage}", continuing without it`);
                    console.error(err);
                }
                await __classPrivateFieldGet(this, _AllureReport_store, "f").restoreState(dumpState, resultsAttachments);
                console.info(`Successfully restored state from "${stage}"`);
            }
        };
        this.done = async () => {
            const summaries = [];
            const remoteHrefs = [];
            const cancelledPluginsIds = new Set();
            if (__classPrivateFieldGet(this, _AllureReport_executionStage, "f") !== "running") {
                throw new Error(initRequired);
            }
            const testResults = await __classPrivateFieldGet(this, _AllureReport_store, "f").allTestResults();
            const testCases = await __classPrivateFieldGet(this, _AllureReport_store, "f").allTestCases();
            const historyDataPoint = createHistory(this.reportUuid, __classPrivateFieldGet(this, _AllureReport_reportName, "f"), testCases, testResults, this.reportUrl);
            __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f").offAll();
            __classPrivateFieldSet(this, _AllureReport_executionStage, "done", "f");
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f")) {
                await this.dumpState();
                return;
            }
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, false, async (plugin, context) => {
                await plugin.done?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"));
            });
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, false, async (plugin, context) => {
                if (__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f") && context.publish) {
                    const pluginFiles = (await context.state.get("files")) ?? {};
                    const pluginFilesEntries = Object.entries(pluginFiles);
                    const progressBar = pluginFilesEntries?.length > 0
                        ? new ProgressBar(`Publishing "${context.id}" report [:bar] :current/:total`, {
                            total: pluginFilesEntries.length,
                            width: 20,
                        })
                        : undefined;
                    const limitFn = pLimit(50);
                    const fns = pluginFilesEntries.map(([filename, filepath]) => limitFn(async () => {
                        if (cancelledPluginsIds.has(context.id)) {
                            return;
                        }
                        if (/^(data|widgets|index\.html$|summary\.json$)/.test(filename)) {
                            await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").addReportFile({
                                reportUuid: this.reportUuid,
                                pluginId: context.id,
                                filename,
                                filepath,
                            });
                        }
                        else {
                            await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").addReportAsset({
                                filename,
                                filepath,
                            });
                        }
                        progressBar?.tick?.();
                    }));
                    progressBar?.render?.();
                    try {
                        await Promise.all(fns);
                    }
                    catch (err) {
                        cancelledPluginsIds.add(context.id);
                        await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").deleteReport({
                            reportUuid: this.reportUuid,
                            pluginId: context.id,
                        });
                        console.error(`Plugin "${context.id}" upload has failed, the plugin won't be published`);
                        console.error(err);
                    }
                }
                const summary = await plugin?.info?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"));
                if (!summary) {
                    return;
                }
                summary.pullRequestHref = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.pullRequestUrl;
                summary.jobHref = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.jobRunUrl;
                if (context.publish && this.reportUrl && !cancelledPluginsIds.has(context.id)) {
                    summary.remoteHref = `${this.reportUrl}/${context.id}/`;
                    remoteHrefs.push(summary.remoteHref);
                }
                summaries.push({
                    ...summary,
                    href: `${context.id}/`,
                });
                await context.reportFiles.addFile("summary.json", Buffer.from(JSON.stringify(summary)));
            });
            if (summaries.length > 1) {
                const summaryPath = await generateSummary(__classPrivateFieldGet(this, _AllureReport_output, "f"), summaries);
                const publishedReports = __classPrivateFieldGet(this, _AllureReport_plugins, "f")
                    .map((plugin) => !!plugin?.options?.publish && !cancelledPluginsIds.has(plugin.id))
                    .filter(Boolean);
                if (__classPrivateFieldGet(this, _AllureReport_instances, "a", _AllureReport_publish_get) && summaryPath && publishedReports.length > 1) {
                    await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")?.addReportFile({
                        reportUuid: this.reportUuid,
                        filename: "index.html",
                        filepath: summaryPath,
                    });
                }
            }
            if (__classPrivateFieldGet(this, _AllureReport_instances, "a", _AllureReport_publish_get)) {
                await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")?.completeReport({
                    reportUuid: this.reportUuid,
                    historyPoint: historyDataPoint,
                });
            }
            let outputDirFiles = [];
            try {
                outputDirFiles = await readdir(__classPrivateFieldGet(this, _AllureReport_output, "f"));
            }
            catch (ignored) { }
            if (outputDirFiles.length === 0) {
                return;
            }
            const reportPath = join(__classPrivateFieldGet(this, _AllureReport_output, "f"), outputDirFiles[0]);
            const outputEntriesStats = await Promise.all(outputDirFiles.map((file) => lstat(join(__classPrivateFieldGet(this, _AllureReport_output, "f"), file))));
            const outputDirectoryEntries = outputEntriesStats.filter((entry) => entry.isDirectory());
            if (outputDirectoryEntries.length === 1) {
                const reportContent = await readdir(reportPath);
                for (const entry of reportContent) {
                    const currentFilePath = join(reportPath, entry);
                    const newFilePath = resolve(dirname(currentFilePath), "..", entry);
                    await rename(currentFilePath, newFilePath);
                }
                await rm(reportPath, { recursive: true });
            }
            for (const dir of __classPrivateFieldGet(this, _AllureReport_stageTempDirs, "f")) {
                try {
                    await rm(dir, { recursive: true });
                }
                catch (ignored) { }
            }
            if (__classPrivateFieldGet(this, _AllureReport_history, "f")) {
                try {
                    await __classPrivateFieldGet(this, _AllureReport_store, "f").appendHistory(historyDataPoint);
                }
                catch (err) {
                    if (err instanceof KnownError) {
                        console.error("Failed to append history", err.message);
                    }
                    else if (err instanceof UnknownError) {
                        console.error("Failed to append history due to unexpected error", err.message);
                    }
                    else {
                        throw err;
                    }
                }
            }
            if (remoteHrefs.length > 0) {
                console.info("Next reports have been published:");
                remoteHrefs.forEach((href) => {
                    console.info(`- ${href}`);
                });
            }
            if (!__classPrivateFieldGet(this, _AllureReport_qualityGate, "f")) {
                return;
            }
            const qualityGateResults = await __classPrivateFieldGet(this, _AllureReport_store, "f").qualityGateResults();
            await writeFile(join(__classPrivateFieldGet(this, _AllureReport_output, "f"), "quality-gate.json"), JSON.stringify(qualityGateResults));
        };
        _AllureReport_eachPlugin.set(this, async (initState, consumer) => {
            if (initState) {
                __classPrivateFieldSet(this, _AllureReport_state, {}, "f");
            }
            for (const { enabled, id, plugin, options } of __classPrivateFieldGet(this, _AllureReport_plugins, "f")) {
                if (!enabled) {
                    continue;
                }
                const pluginState = __classPrivateFieldGet(this, _AllureReport_instances, "m", _AllureReport_getPluginState).call(this, initState, id);
                if (!pluginState) {
                    console.error("plugin error: state is empty");
                    continue;
                }
                if (initState) {
                    await pluginState.set("files", {});
                }
                const pluginFiles = new PluginFiles(__classPrivateFieldGet(this, _AllureReport_reportFiles, "f"), id, async (key, filepath) => {
                    const currentPluginState = __classPrivateFieldGet(this, _AllureReport_instances, "m", _AllureReport_getPluginState).call(this, false, id);
                    const files = await currentPluginState?.get("files");
                    if (!files) {
                        return;
                    }
                    files[key] = filepath;
                });
                const pluginContext = {
                    id,
                    publish: !!options?.publish,
                    allureVersion: version,
                    reportUuid: this.reportUuid,
                    reportName: __classPrivateFieldGet(this, _AllureReport_reportName, "f"),
                    state: pluginState,
                    reportFiles: pluginFiles,
                    reportUrl: this.reportUrl,
                    ci: __classPrivateFieldGet(this, _AllureReport_ci, "f"),
                };
                try {
                    await consumer.call(this, plugin, pluginContext);
                    if (initState) {
                        __classPrivateFieldGet(this, _AllureReport_state, "f")[id] = pluginState;
                    }
                }
                catch (e) {
                    console.error(`plugin ${id} error`, e);
                }
            }
        });
        const { name, readers = [allure1, allure2, cucumberjson, junitXml, attachments], plugins = [], known, reportFiles, realTime, historyPath, historyLimit, defaultLabels = {}, variables = {}, environment, environments, output, qualityGate, stage, allureService: allureServiceConfig, } = opts;
        __classPrivateFieldSet(this, _AllureReport_allureServiceClient, allureServiceConfig?.accessToken
            ? new AllureServiceClient(allureServiceConfig)
            : undefined, "f");
        this.reportUuid = randomUUID();
        __classPrivateFieldSet(this, _AllureReport_ci, detect(), "f");
        const reportTitleSuffix = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.pullRequestName ?? __classPrivateFieldGet(this, _AllureReport_ci, "f")?.jobRunName;
        __classPrivateFieldSet(this, _AllureReport_reportName, [name, reportTitleSuffix].filter(Boolean).join(" â€“ "), "f");
        __classPrivateFieldSet(this, _AllureReport_reportVariables, variables, "f");
        __classPrivateFieldSet(this, _AllureReport_eventEmitter, new EventEmitter(), "f");
        __classPrivateFieldSet(this, _AllureReport_realtimeDispatcher, new RealtimeEventsDispatcher(__classPrivateFieldGet(this, _AllureReport_eventEmitter, "f")), "f");
        __classPrivateFieldSet(this, _AllureReport_realtimeSubscriber, new RealtimeSubscriber(__classPrivateFieldGet(this, _AllureReport_eventEmitter, "f")), "f");
        __classPrivateFieldSet(this, _AllureReport_realTime, realTime, "f");
        __classPrivateFieldSet(this, _AllureReport_stage, stage, "f");
        if (qualityGate) {
            __classPrivateFieldSet(this, _AllureReport_qualityGate, new QualityGate(qualityGate), "f");
        }
        if (__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")) {
            __classPrivateFieldSet(this, _AllureReport_history, new AllureRemoteHistory({
                allureServiceClient: __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f"),
                branch: __classPrivateFieldGet(this, _AllureReport_ci, "f")?.jobRunBranch,
                limit: historyLimit,
            }), "f");
        }
        else if (historyPath) {
            __classPrivateFieldSet(this, _AllureReport_history, new AllureLocalHistory({
                historyPath,
                limit: historyLimit,
            }), "f");
        }
        __classPrivateFieldSet(this, _AllureReport_store, new DefaultAllureStore({
            realtimeSubscriber: __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f"),
            realtimeDispatcher: __classPrivateFieldGet(this, _AllureReport_realtimeDispatcher, "f"),
            reportVariables: variables,
            environmentsConfig: environments,
            history: __classPrivateFieldGet(this, _AllureReport_history, "f"),
            known,
            defaultLabels,
            environment,
        }), "f");
        __classPrivateFieldSet(this, _AllureReport_readers, [...readers], "f");
        __classPrivateFieldSet(this, _AllureReport_plugins, [...plugins], "f");
        __classPrivateFieldSet(this, _AllureReport_reportFiles, reportFiles, "f");
        __classPrivateFieldSet(this, _AllureReport_output, output, "f");
    }
    get hasQualityGate() {
        return !!__classPrivateFieldGet(this, _AllureReport_qualityGate, "f");
    }
    get store() {
        return __classPrivateFieldGet(this, _AllureReport_store, "f");
    }
    get realtimeSubscriber() {
        return __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f");
    }
    get realtimeDispatcher() {
        return __classPrivateFieldGet(this, _AllureReport_realtimeDispatcher, "f");
    }
}
_AllureReport_reportName = new WeakMap(), _AllureReport_reportVariables = new WeakMap(), _AllureReport_ci = new WeakMap(), _AllureReport_store = new WeakMap(), _AllureReport_readers = new WeakMap(), _AllureReport_plugins = new WeakMap(), _AllureReport_reportFiles = new WeakMap(), _AllureReport_eventEmitter = new WeakMap(), _AllureReport_realtimeSubscriber = new WeakMap(), _AllureReport_realtimeDispatcher = new WeakMap(), _AllureReport_realTime = new WeakMap(), _AllureReport_output = new WeakMap(), _AllureReport_history = new WeakMap(), _AllureReport_allureServiceClient = new WeakMap(), _AllureReport_qualityGate = new WeakMap(), _AllureReport_stage = new WeakMap(), _AllureReport_stageTempDirs = new WeakMap(), _AllureReport_state = new WeakMap(), _AllureReport_executionStage = new WeakMap(), _AllureReport_update = new WeakMap(), _AllureReport_eachPlugin = new WeakMap(), _AllureReport_instances = new WeakSet(), _AllureReport_publish_get = function _AllureReport_publish_get() {
    return __classPrivateFieldGet(this, _AllureReport_plugins, "f").some(({ enabled, options }) => enabled && options.publish);
}, _AllureReport_getPluginState = function _AllureReport_getPluginState(init, id) {
    return init ? new DefaultPluginState({}) : __classPrivateFieldGet(this, _AllureReport_state, "f")?.[id];
};
