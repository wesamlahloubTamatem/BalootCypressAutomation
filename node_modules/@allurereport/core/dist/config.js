import * as console from "node:console";
import { readFile, stat } from "node:fs/promises";
import { extname, resolve } from "node:path";
import * as process from "node:process";
import { parse } from "yaml";
import { readKnownIssues } from "./known.js";
import { FileSystemReportFiles } from "./plugin.js";
import { importWrapper } from "./utils/module.js";
import { normalizeImportPath } from "./utils/path.js";
const CONFIG_FILENAMES = [
    "allurerc.js",
    "allurerc.mjs",
    "allurerc.cjs",
    "allurerc.json",
    "allurerc.yaml",
    "allurerc.yml",
];
const DEFAULT_CONFIG = {};
export const getPluginId = (key) => {
    return key.replace(/^@.*\//, "").replace(/[/\\]/g, "-");
};
export const findConfig = async (cwd, configPath) => {
    if (configPath) {
        const resolved = resolve(cwd, configPath);
        try {
            const stats = await stat(resolved);
            if (stats.isFile()) {
                return resolved;
            }
        }
        catch (e) {
            console.error(e);
        }
        throw new Error(`invalid config path ${resolved}: not a regular file`);
    }
    for (const configFilename of CONFIG_FILENAMES) {
        const resolved = resolve(cwd, configFilename);
        try {
            const stats = await stat(resolved);
            if (stats.isFile()) {
                return resolved;
            }
        }
        catch (ignored) {
        }
    }
};
export const validateConfig = (config) => {
    const supportedFields = [
        "name",
        "output",
        "open",
        "port",
        "historyPath",
        "historyLimit",
        "knownIssuesPath",
        "plugins",
        "defaultLabels",
        "variables",
        "environments",
        "appendHistory",
        "qualityGate",
        "allureService",
    ];
    const unsupportedFields = Object.keys(config).filter((key) => !supportedFields.includes(key));
    return {
        valid: unsupportedFields.length === 0,
        fields: unsupportedFields,
    };
};
export const loadYamlConfig = async (configPath) => {
    try {
        const rawConfig = await readFile(configPath, "utf-8");
        const parsedConfig = parse(rawConfig);
        return parsedConfig || DEFAULT_CONFIG;
    }
    catch (err) {
        if (err?.code === "ENOENT") {
            return DEFAULT_CONFIG;
        }
        throw err;
    }
};
export const loadJsonConfig = async (configPath) => {
    try {
        const rawConfig = await readFile(configPath, "utf-8");
        const parsedConfig = JSON.parse(rawConfig);
        return parsedConfig || DEFAULT_CONFIG;
    }
    catch (err) {
        if (err?.code === "ENOENT") {
            return DEFAULT_CONFIG;
        }
        throw err;
    }
};
export const loadJsConfig = async (configPath) => {
    return (await import(normalizeImportPath(configPath))).default;
};
export const resolveConfig = async (config, override = {}) => {
    const validationResult = validateConfig(config);
    if (!validationResult.valid) {
        throw new Error(`The provided Allure config contains unsupported fields: ${validationResult.fields.join(", ")}`);
    }
    const name = override.name ?? config.name ?? "Allure Report";
    const open = override.open ?? config.open ?? false;
    const port = override.port ?? config.port ?? undefined;
    const historyPath = override.historyPath ?? config.historyPath;
    const historyLimit = override.historyLimit ?? config.historyLimit;
    const appendHistory = config.appendHistory ?? true;
    const knownIssuesPath = resolve(override.knownIssuesPath ?? config.knownIssuesPath ?? "./allure/known.json");
    const output = resolve(override.output ?? config.output ?? "./allure-report");
    const known = await readKnownIssues(knownIssuesPath);
    const variables = config.variables ?? {};
    const environments = config.environments ?? {};
    const plugins = Object.keys(override?.plugins ?? config?.plugins ?? {}).length === 0
        ? {
            awesome: {
                options: {},
            },
        }
        : config.plugins;
    const pluginInstances = await resolvePlugins(plugins);
    return {
        name,
        output,
        open,
        port,
        knownIssuesPath,
        known,
        variables,
        environments,
        appendHistory,
        historyLimit,
        historyPath: historyPath ? resolve(historyPath) : undefined,
        reportFiles: new FileSystemReportFiles(output),
        plugins: pluginInstances,
        defaultLabels: config.defaultLabels ?? {},
        qualityGate: config.qualityGate,
        allureService: config.allureService,
    };
};
export const readConfig = async (cwd = process.cwd(), configPath, override) => {
    const cfg = (await findConfig(cwd, configPath)) ?? "";
    let config;
    switch (extname(cfg)) {
        case ".json":
            config = await loadJsonConfig(cfg);
            break;
        case ".yaml":
        case ".yml":
            config = await loadYamlConfig(cfg);
            break;
        case ".js":
        case ".cjs":
        case ".mjs":
            config = await loadJsConfig(cfg);
            break;
        default:
            config = DEFAULT_CONFIG;
    }
    const fullConfig = await resolveConfig(config, override);
    return fullConfig;
};
export const getPluginInstance = (config, predicate) => {
    return config?.plugins?.find(predicate);
};
export const resolvePlugin = async (path) => {
    if (!path.startsWith("@allurereport/plugin-")) {
        try {
            const module = await importWrapper(`@allurereport/plugin-${path}`);
            return module.default;
        }
        catch (err) { }
    }
    try {
        const module = await importWrapper(path);
        return module.default;
    }
    catch (err) {
        throw new Error(`Cannot resolve plugin: ${path}`);
    }
};
const resolvePlugins = async (plugins) => {
    const pluginInstances = [];
    for (const id in plugins) {
        const pluginConfig = plugins[id];
        const pluginId = getPluginId(id);
        const Plugin = await resolvePlugin(pluginConfig.import ?? id);
        pluginInstances.push({
            id: pluginId,
            enabled: pluginConfig.enabled ?? true,
            options: pluginConfig.options ?? {},
            plugin: new Plugin(pluginConfig.options),
        });
    }
    return pluginInstances;
};
