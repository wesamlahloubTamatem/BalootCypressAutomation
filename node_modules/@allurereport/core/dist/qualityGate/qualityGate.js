var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _QualityGateState_state;
import { gray, red } from "yoctocolors";
import { qualityGateDefaultRules } from "./rules.js";
export const stringifyQualityGateResults = (results) => {
    if (results.length === 0) {
        return "";
    }
    const lines = [red("Quality Gate failed with following issues:")];
    const maxMessageLength = Math.max(...results.map((r) => r.message.length));
    lines.push("");
    results.forEach((result) => {
        lines.push(` ${red("тип")} ${result.message.padEnd(maxMessageLength, " ")}    ${gray(result.rule)}`);
    });
    lines.push("");
    lines.push(red(`${results.length} quality gate rules have been failed.`));
    return lines.join("\n");
};
export const convertQualityGateResultsToTestErrors = (results) => {
    return results.map((result) => ({
        message: `Quality Gate (${result.rule}): ${result.message}`,
        actual: result.actual,
        expected: result.expected,
    }));
};
export class QualityGateState {
    constructor() {
        _QualityGateState_state.set(this, {});
    }
    setResult(rule, value) {
        __classPrivateFieldGet(this, _QualityGateState_state, "f")[rule] = value;
    }
    getResult(rule) {
        return __classPrivateFieldGet(this, _QualityGateState_state, "f")[rule];
    }
}
_QualityGateState_state = new WeakMap();
export class QualityGate {
    constructor(config) {
        this.config = config;
    }
    async validate(payload) {
        const { state, trs, knownIssues } = payload;
        const { rules, use = [...qualityGateDefaultRules] } = this.config;
        const results = [];
        let fastFailed = false;
        if (!rules?.length) {
            return {
                fastFailed: false,
                results,
            };
        }
        for (const ruleset of rules) {
            if (fastFailed) {
                break;
            }
            for (const [key, expected] of Object.entries(ruleset)) {
                if (key === "filter" || key === "id" || key === "fastFail") {
                    continue;
                }
                const rule = use.filter((r) => r.rule === key).pop();
                if (!rule) {
                    throw new Error(`Rule ${key} is not provided. Make sure you have provided it in the "use" field of the quality gate config!`);
                }
                const trsToValidate = ruleset.filter ? trs.filter(ruleset.filter) : trs;
                const ruleId = ruleset.id ? [ruleset.id, rule.rule].join("/") : rule.rule;
                const result = await rule.validate({
                    trs: trsToValidate,
                    state: {
                        getResult: () => state?.getResult?.(ruleId),
                        setResult: (value) => state?.setResult?.(ruleId, value),
                    },
                    expected,
                    knownIssues,
                });
                if (result.success) {
                    continue;
                }
                results.push({
                    ...result,
                    expected,
                    rule: ruleset.id ? [ruleset.id, rule.rule].join("/") : rule.rule,
                    message: rule.message({
                        actual: result.actual,
                        expected,
                    }),
                });
                if (ruleset.fastFail) {
                    fastFailed = true;
                    break;
                }
            }
        }
        return {
            fastFailed,
            results,
        };
    }
}
