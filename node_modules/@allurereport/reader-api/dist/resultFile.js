var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BaseResultFile_instances, _BaseResultFile_detectContentType;
import { lookup } from "mime-types";
import { ReadStream, closeSync, createReadStream, createWriteStream, existsSync, openSync, readSync, statSync, } from "node:fs";
import "node:fs/promises";
import { basename } from "node:path";
import { pipeline } from "node:stream/promises";
import { detectContentType } from "./detect.js";
import { extension } from "./utils.js";
export class BaseResultFile {
    constructor(fileName) {
        _BaseResultFile_instances.add(this);
        this.extension = false;
        this.contentType = false;
        this.fileName = fileName;
    }
    getContentType() {
        if (this.contentType === false) {
            this.contentType = __classPrivateFieldGet(this, _BaseResultFile_instances, "m", _BaseResultFile_detectContentType).call(this);
        }
        return this.contentType;
    }
    getOriginalFileName() {
        return this.fileName;
    }
    getExtension() {
        if (this.extension === false) {
            this.extension = extension(this.getOriginalFileName()) ?? extension("", this.getContentType()) ?? "";
        }
        return this.extension;
    }
    async asJson() {
        return await this.readContent(readSteamToJson);
    }
    async asUtf8String() {
        return await this.readContent(readStreamToString);
    }
    async asBuffer() {
        return await this.readContent(readStreamToBuffer);
    }
    async writeTo(path) {
        await this.readContent(async (stream) => {
            await pipeline(stream, createWriteStream(path));
        });
    }
    async readContent(transform) {
        const content = this.getContent();
        return content ? await transform(content) : undefined;
    }
}
_BaseResultFile_instances = new WeakSet(), _BaseResultFile_detectContentType = function _BaseResultFile_detectContentType() {
    const res = lookup(this.getOriginalFileName());
    if (res === false) {
        const magicHeader = this.readMagicHeader();
        if (!magicHeader) {
            return undefined;
        }
        return detectContentType(magicHeader);
    }
    return res;
};
const magicHeaderLength = 1024;
export class BufferResultFile extends BaseResultFile {
    constructor(buffer, fileName) {
        super(basename(fileName));
        this.buffer = buffer;
    }
    getContent() {
        return ReadStream.from(this.buffer);
    }
    readMagicHeader() {
        return this.buffer.subarray(0, magicHeaderLength);
    }
    getContentLength() {
        return this.buffer.length;
    }
}
export class PathResultFile extends BaseResultFile {
    constructor(path, fileName = basename(path)) {
        super(fileName);
        this.path = path;
    }
    getContent() {
        if (existsSync(this.path)) {
            return createReadStream(this.path);
        }
        else {
            return undefined;
        }
    }
    readMagicHeader() {
        if (existsSync(this.path)) {
            const buf = new Uint8Array(magicHeaderLength);
            const fd = openSync(this.path, "r");
            try {
                const size = readSync(fd, buf, 0, magicHeaderLength, null);
                if (size === 0) {
                    return undefined;
                }
                if (size < magicHeaderLength) {
                    return buf.subarray(0, size);
                }
                return buf;
            }
            finally {
                closeSync(fd);
            }
        }
        else {
            return undefined;
        }
    }
    getContentLength() {
        return statSync(this.path, { throwIfNoEntry: false })?.size;
    }
}
export const readSteamToJson = async (stream) => {
    const text = await readStreamToString(stream);
    return JSON.parse(text);
};
export const readStreamToString = async (stream) => {
    const res = await readStreamToBuffer(stream);
    return res.toString("utf-8");
};
export const readStreamToBuffer = async (stream) => {
    const chunks = [];
    for await (const chunk of stream) {
        chunks.push(Buffer.from(chunk));
    }
    return Buffer.concat(chunks);
};
