import { spawn } from "node:child_process";
const LINE_SPLIT_PATTERN = /\r\n|\r|\n/;
export const invokeCliTool = async (executable, args, { timeout, timeoutSignal, ignoreStderr, encoding, exitCode: expectedExitCode = 0 } = {}) => {
    const toolProcess = spawn(executable, args, {
        stdio: ["ignore", "ignore", ignoreStderr ? "ignore" : "pipe"],
        shell: false,
        timeout,
        killSignal: timeoutSignal,
    });
    const stderr = [];
    if (!ignoreStderr) {
        toolProcess.stderr?.setEncoding(encoding ?? "utf-8").on("data", (chunk) => stderr.push(String(chunk)));
    }
    let onSuccess;
    let onError;
    const resultPromise = new Promise((resolve, reject) => {
        onSuccess = resolve;
        onError = reject;
    });
    toolProcess.on("exit", (code, signal) => {
        if (signal) {
            onError(new Error(timeout && toolProcess.killed
                ? `${executable} was terminated by timeout (${timeout} ms)`
                : `${executable} was terminated with ${signal}`));
            return;
        }
        if (typeof expectedExitCode === "number" ? code !== expectedExitCode : expectedExitCode(code)) {
            onError(new Error(`${executable} finished with an unexpected exit code ${code}`));
            return;
        }
        onSuccess();
    });
    return await resultPromise;
};
export const invokeStdoutCliTool = async function* (executable, args, options) {
    const { timeout, timeoutSignal, encoding, stderrEncoding, exitCode: expectedExitCode = 0, ignoreStderr, } = options ?? {};
    const emitTextChunk = (chunk) => {
        const lines = (unfinishedLineBuffer + chunk).split(LINE_SPLIT_PATTERN);
        if (lines.length) {
            unfinishedLineBuffer = lines.at(-1);
            stdoutChunks.push(...lines.slice(0, -1));
            maybeContinueConsumption();
        }
    };
    const emitFinalTextChunk = () => {
        if (unfinishedLineBuffer) {
            stdoutChunks.push(unfinishedLineBuffer);
            unfinishedLineBuffer = "";
            maybeContinueConsumption();
        }
    };
    const emitBinaryChunk = (chunk) => {
        stdoutChunks.push(chunk);
        maybeContinueConsumption();
    };
    const emitError = (message) => {
        if (stderrChunks.length) {
            message = `${message}\n\nStandard error:\n\n${stderrChunks.join("")}`;
        }
        bufferedError = new Error(message);
        maybeContinueConsumption();
    };
    const checkExitCode = (code) => {
        if (typeof expectedExitCode === "number") {
            return code === expectedExitCode;
        }
        return expectedExitCode(code);
    };
    const maybeContinueConsumption = () => {
        if (continueConsumption) {
            const continueConsumptionLocal = continueConsumption;
            continueConsumption = undefined;
            continueConsumptionLocal();
        }
    };
    const stdoutChunks = [];
    let unfinishedLineBuffer = "";
    let done = false;
    let bufferedError;
    const stderrChunks = [];
    let continueConsumption;
    const toolProcess = spawn(executable, args, {
        stdio: ["ignore", "pipe", ignoreStderr ? "ignore" : "pipe"],
        shell: false,
        timeout,
        killSignal: timeoutSignal,
    });
    const { stdout, stderr } = toolProcess;
    if (stdout) {
        if (encoding) {
            stdout.setEncoding(encoding).on("data", emitTextChunk);
        }
        else {
            stdout.on("data", emitBinaryChunk);
        }
    }
    if (stderr) {
        stderr.setEncoding(stderrEncoding ?? encoding ?? "utf-8").on("data", stderrChunks.push.bind(stderrChunks));
    }
    toolProcess.on("exit", (code, signal) => {
        emitFinalTextChunk();
        done = true;
        if (bufferedError) {
            return;
        }
        if (signal) {
            emitError(timeout && toolProcess.killed
                ? `${executable} was terminated by timeout (${timeout} ms)`
                : `${executable} was terminated with ${signal}`);
            return;
        }
        if (!checkExitCode(code)) {
            emitError(`${executable} finished with an unexpected exit code ${code}`);
            return;
        }
        continueConsumption?.();
    });
    while (true) {
        if (stdoutChunks.length) {
            yield* stdoutChunks;
            stdoutChunks.splice(0);
        }
        if (bufferedError) {
            throw bufferedError;
        }
        if (done) {
            return;
        }
        await new Promise((resolve) => {
            continueConsumption = resolve;
        });
    }
};
export const collectCliToolStdoutText = async (executable, args, options = {}) => {
    const { encoding = "utf-8", ...rest } = options;
    const chunks = [];
    for await (const chunk of invokeStdoutCliTool(executable, args, rest)) {
        chunks.push(chunk);
    }
    return Buffer.concat(chunks).toString(encoding);
};
export const invokeJsonCliTool = async (tool, args, options = {}) => {
    const text = await collectCliToolStdoutText(tool, args, options);
    return JSON.parse(text);
};
